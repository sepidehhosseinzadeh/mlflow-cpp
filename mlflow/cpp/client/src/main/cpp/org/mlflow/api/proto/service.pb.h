// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: service.proto

#ifndef PROTOBUF_INCLUDED_service_2eproto
#define PROTOBUF_INCLUDED_service_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "scalapb/scalapb.pb.h"
#include "databricks.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_service_2eproto 

namespace protobuf_service_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[52];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_service_2eproto
namespace mlflow {
class CreateExperiment;
class CreateExperimentDefaultTypeInternal;
extern CreateExperimentDefaultTypeInternal _CreateExperiment_default_instance_;
class CreateExperiment_Response;
class CreateExperiment_ResponseDefaultTypeInternal;
extern CreateExperiment_ResponseDefaultTypeInternal _CreateExperiment_Response_default_instance_;
class CreateRun;
class CreateRunDefaultTypeInternal;
extern CreateRunDefaultTypeInternal _CreateRun_default_instance_;
class CreateRun_Response;
class CreateRun_ResponseDefaultTypeInternal;
extern CreateRun_ResponseDefaultTypeInternal _CreateRun_Response_default_instance_;
class DeleteExperiment;
class DeleteExperimentDefaultTypeInternal;
extern DeleteExperimentDefaultTypeInternal _DeleteExperiment_default_instance_;
class DeleteExperiment_Response;
class DeleteExperiment_ResponseDefaultTypeInternal;
extern DeleteExperiment_ResponseDefaultTypeInternal _DeleteExperiment_Response_default_instance_;
class DeleteRun;
class DeleteRunDefaultTypeInternal;
extern DeleteRunDefaultTypeInternal _DeleteRun_default_instance_;
class DeleteRun_Response;
class DeleteRun_ResponseDefaultTypeInternal;
extern DeleteRun_ResponseDefaultTypeInternal _DeleteRun_Response_default_instance_;
class DoubleClause;
class DoubleClauseDefaultTypeInternal;
extern DoubleClauseDefaultTypeInternal _DoubleClause_default_instance_;
class Experiment;
class ExperimentDefaultTypeInternal;
extern ExperimentDefaultTypeInternal _Experiment_default_instance_;
class FileInfo;
class FileInfoDefaultTypeInternal;
extern FileInfoDefaultTypeInternal _FileInfo_default_instance_;
class FloatClause;
class FloatClauseDefaultTypeInternal;
extern FloatClauseDefaultTypeInternal _FloatClause_default_instance_;
class GetArtifact;
class GetArtifactDefaultTypeInternal;
extern GetArtifactDefaultTypeInternal _GetArtifact_default_instance_;
class GetArtifact_Response;
class GetArtifact_ResponseDefaultTypeInternal;
extern GetArtifact_ResponseDefaultTypeInternal _GetArtifact_Response_default_instance_;
class GetExperiment;
class GetExperimentDefaultTypeInternal;
extern GetExperimentDefaultTypeInternal _GetExperiment_default_instance_;
class GetExperiment_Response;
class GetExperiment_ResponseDefaultTypeInternal;
extern GetExperiment_ResponseDefaultTypeInternal _GetExperiment_Response_default_instance_;
class GetMetric;
class GetMetricDefaultTypeInternal;
extern GetMetricDefaultTypeInternal _GetMetric_default_instance_;
class GetMetricHistory;
class GetMetricHistoryDefaultTypeInternal;
extern GetMetricHistoryDefaultTypeInternal _GetMetricHistory_default_instance_;
class GetMetricHistory_Response;
class GetMetricHistory_ResponseDefaultTypeInternal;
extern GetMetricHistory_ResponseDefaultTypeInternal _GetMetricHistory_Response_default_instance_;
class GetMetric_Response;
class GetMetric_ResponseDefaultTypeInternal;
extern GetMetric_ResponseDefaultTypeInternal _GetMetric_Response_default_instance_;
class GetParam;
class GetParamDefaultTypeInternal;
extern GetParamDefaultTypeInternal _GetParam_default_instance_;
class GetParam_Response;
class GetParam_ResponseDefaultTypeInternal;
extern GetParam_ResponseDefaultTypeInternal _GetParam_Response_default_instance_;
class GetRun;
class GetRunDefaultTypeInternal;
extern GetRunDefaultTypeInternal _GetRun_default_instance_;
class GetRun_Response;
class GetRun_ResponseDefaultTypeInternal;
extern GetRun_ResponseDefaultTypeInternal _GetRun_Response_default_instance_;
class ListArtifacts;
class ListArtifactsDefaultTypeInternal;
extern ListArtifactsDefaultTypeInternal _ListArtifacts_default_instance_;
class ListArtifacts_Response;
class ListArtifacts_ResponseDefaultTypeInternal;
extern ListArtifacts_ResponseDefaultTypeInternal _ListArtifacts_Response_default_instance_;
class ListExperiments;
class ListExperimentsDefaultTypeInternal;
extern ListExperimentsDefaultTypeInternal _ListExperiments_default_instance_;
class ListExperiments_Response;
class ListExperiments_ResponseDefaultTypeInternal;
extern ListExperiments_ResponseDefaultTypeInternal _ListExperiments_Response_default_instance_;
class LogMetric;
class LogMetricDefaultTypeInternal;
extern LogMetricDefaultTypeInternal _LogMetric_default_instance_;
class LogMetric_Response;
class LogMetric_ResponseDefaultTypeInternal;
extern LogMetric_ResponseDefaultTypeInternal _LogMetric_Response_default_instance_;
class LogParam;
class LogParamDefaultTypeInternal;
extern LogParamDefaultTypeInternal _LogParam_default_instance_;
class LogParam_Response;
class LogParam_ResponseDefaultTypeInternal;
extern LogParam_ResponseDefaultTypeInternal _LogParam_Response_default_instance_;
class Metric;
class MetricDefaultTypeInternal;
extern MetricDefaultTypeInternal _Metric_default_instance_;
class MetricSearchExpression;
class MetricSearchExpressionDefaultTypeInternal;
extern MetricSearchExpressionDefaultTypeInternal _MetricSearchExpression_default_instance_;
class Param;
class ParamDefaultTypeInternal;
extern ParamDefaultTypeInternal _Param_default_instance_;
class ParameterSearchExpression;
class ParameterSearchExpressionDefaultTypeInternal;
extern ParameterSearchExpressionDefaultTypeInternal _ParameterSearchExpression_default_instance_;
class RestoreExperiment;
class RestoreExperimentDefaultTypeInternal;
extern RestoreExperimentDefaultTypeInternal _RestoreExperiment_default_instance_;
class RestoreExperiment_Response;
class RestoreExperiment_ResponseDefaultTypeInternal;
extern RestoreExperiment_ResponseDefaultTypeInternal _RestoreExperiment_Response_default_instance_;
class RestoreRun;
class RestoreRunDefaultTypeInternal;
extern RestoreRunDefaultTypeInternal _RestoreRun_default_instance_;
class RestoreRun_Response;
class RestoreRun_ResponseDefaultTypeInternal;
extern RestoreRun_ResponseDefaultTypeInternal _RestoreRun_Response_default_instance_;
class Run;
class RunDefaultTypeInternal;
extern RunDefaultTypeInternal _Run_default_instance_;
class RunData;
class RunDataDefaultTypeInternal;
extern RunDataDefaultTypeInternal _RunData_default_instance_;
class RunInfo;
class RunInfoDefaultTypeInternal;
extern RunInfoDefaultTypeInternal _RunInfo_default_instance_;
class RunTag;
class RunTagDefaultTypeInternal;
extern RunTagDefaultTypeInternal _RunTag_default_instance_;
class SearchExpression;
class SearchExpressionDefaultTypeInternal;
extern SearchExpressionDefaultTypeInternal _SearchExpression_default_instance_;
class SearchRuns;
class SearchRunsDefaultTypeInternal;
extern SearchRunsDefaultTypeInternal _SearchRuns_default_instance_;
class SearchRuns_Response;
class SearchRuns_ResponseDefaultTypeInternal;
extern SearchRuns_ResponseDefaultTypeInternal _SearchRuns_Response_default_instance_;
class SetTag;
class SetTagDefaultTypeInternal;
extern SetTagDefaultTypeInternal _SetTag_default_instance_;
class SetTag_Response;
class SetTag_ResponseDefaultTypeInternal;
extern SetTag_ResponseDefaultTypeInternal _SetTag_Response_default_instance_;
class StringClause;
class StringClauseDefaultTypeInternal;
extern StringClauseDefaultTypeInternal _StringClause_default_instance_;
class UpdateRun;
class UpdateRunDefaultTypeInternal;
extern UpdateRunDefaultTypeInternal _UpdateRun_default_instance_;
class UpdateRun_Response;
class UpdateRun_ResponseDefaultTypeInternal;
extern UpdateRun_ResponseDefaultTypeInternal _UpdateRun_Response_default_instance_;
}  // namespace mlflow
namespace google {
namespace protobuf {
template<> ::mlflow::CreateExperiment* Arena::CreateMaybeMessage<::mlflow::CreateExperiment>(Arena*);
template<> ::mlflow::CreateExperiment_Response* Arena::CreateMaybeMessage<::mlflow::CreateExperiment_Response>(Arena*);
template<> ::mlflow::CreateRun* Arena::CreateMaybeMessage<::mlflow::CreateRun>(Arena*);
template<> ::mlflow::CreateRun_Response* Arena::CreateMaybeMessage<::mlflow::CreateRun_Response>(Arena*);
template<> ::mlflow::DeleteExperiment* Arena::CreateMaybeMessage<::mlflow::DeleteExperiment>(Arena*);
template<> ::mlflow::DeleteExperiment_Response* Arena::CreateMaybeMessage<::mlflow::DeleteExperiment_Response>(Arena*);
template<> ::mlflow::DeleteRun* Arena::CreateMaybeMessage<::mlflow::DeleteRun>(Arena*);
template<> ::mlflow::DeleteRun_Response* Arena::CreateMaybeMessage<::mlflow::DeleteRun_Response>(Arena*);
template<> ::mlflow::DoubleClause* Arena::CreateMaybeMessage<::mlflow::DoubleClause>(Arena*);
template<> ::mlflow::Experiment* Arena::CreateMaybeMessage<::mlflow::Experiment>(Arena*);
template<> ::mlflow::FileInfo* Arena::CreateMaybeMessage<::mlflow::FileInfo>(Arena*);
template<> ::mlflow::FloatClause* Arena::CreateMaybeMessage<::mlflow::FloatClause>(Arena*);
template<> ::mlflow::GetArtifact* Arena::CreateMaybeMessage<::mlflow::GetArtifact>(Arena*);
template<> ::mlflow::GetArtifact_Response* Arena::CreateMaybeMessage<::mlflow::GetArtifact_Response>(Arena*);
template<> ::mlflow::GetExperiment* Arena::CreateMaybeMessage<::mlflow::GetExperiment>(Arena*);
template<> ::mlflow::GetExperiment_Response* Arena::CreateMaybeMessage<::mlflow::GetExperiment_Response>(Arena*);
template<> ::mlflow::GetMetric* Arena::CreateMaybeMessage<::mlflow::GetMetric>(Arena*);
template<> ::mlflow::GetMetricHistory* Arena::CreateMaybeMessage<::mlflow::GetMetricHistory>(Arena*);
template<> ::mlflow::GetMetricHistory_Response* Arena::CreateMaybeMessage<::mlflow::GetMetricHistory_Response>(Arena*);
template<> ::mlflow::GetMetric_Response* Arena::CreateMaybeMessage<::mlflow::GetMetric_Response>(Arena*);
template<> ::mlflow::GetParam* Arena::CreateMaybeMessage<::mlflow::GetParam>(Arena*);
template<> ::mlflow::GetParam_Response* Arena::CreateMaybeMessage<::mlflow::GetParam_Response>(Arena*);
template<> ::mlflow::GetRun* Arena::CreateMaybeMessage<::mlflow::GetRun>(Arena*);
template<> ::mlflow::GetRun_Response* Arena::CreateMaybeMessage<::mlflow::GetRun_Response>(Arena*);
template<> ::mlflow::ListArtifacts* Arena::CreateMaybeMessage<::mlflow::ListArtifacts>(Arena*);
template<> ::mlflow::ListArtifacts_Response* Arena::CreateMaybeMessage<::mlflow::ListArtifacts_Response>(Arena*);
template<> ::mlflow::ListExperiments* Arena::CreateMaybeMessage<::mlflow::ListExperiments>(Arena*);
template<> ::mlflow::ListExperiments_Response* Arena::CreateMaybeMessage<::mlflow::ListExperiments_Response>(Arena*);
template<> ::mlflow::LogMetric* Arena::CreateMaybeMessage<::mlflow::LogMetric>(Arena*);
template<> ::mlflow::LogMetric_Response* Arena::CreateMaybeMessage<::mlflow::LogMetric_Response>(Arena*);
template<> ::mlflow::LogParam* Arena::CreateMaybeMessage<::mlflow::LogParam>(Arena*);
template<> ::mlflow::LogParam_Response* Arena::CreateMaybeMessage<::mlflow::LogParam_Response>(Arena*);
template<> ::mlflow::Metric* Arena::CreateMaybeMessage<::mlflow::Metric>(Arena*);
template<> ::mlflow::MetricSearchExpression* Arena::CreateMaybeMessage<::mlflow::MetricSearchExpression>(Arena*);
template<> ::mlflow::Param* Arena::CreateMaybeMessage<::mlflow::Param>(Arena*);
template<> ::mlflow::ParameterSearchExpression* Arena::CreateMaybeMessage<::mlflow::ParameterSearchExpression>(Arena*);
template<> ::mlflow::RestoreExperiment* Arena::CreateMaybeMessage<::mlflow::RestoreExperiment>(Arena*);
template<> ::mlflow::RestoreExperiment_Response* Arena::CreateMaybeMessage<::mlflow::RestoreExperiment_Response>(Arena*);
template<> ::mlflow::RestoreRun* Arena::CreateMaybeMessage<::mlflow::RestoreRun>(Arena*);
template<> ::mlflow::RestoreRun_Response* Arena::CreateMaybeMessage<::mlflow::RestoreRun_Response>(Arena*);
template<> ::mlflow::Run* Arena::CreateMaybeMessage<::mlflow::Run>(Arena*);
template<> ::mlflow::RunData* Arena::CreateMaybeMessage<::mlflow::RunData>(Arena*);
template<> ::mlflow::RunInfo* Arena::CreateMaybeMessage<::mlflow::RunInfo>(Arena*);
template<> ::mlflow::RunTag* Arena::CreateMaybeMessage<::mlflow::RunTag>(Arena*);
template<> ::mlflow::SearchExpression* Arena::CreateMaybeMessage<::mlflow::SearchExpression>(Arena*);
template<> ::mlflow::SearchRuns* Arena::CreateMaybeMessage<::mlflow::SearchRuns>(Arena*);
template<> ::mlflow::SearchRuns_Response* Arena::CreateMaybeMessage<::mlflow::SearchRuns_Response>(Arena*);
template<> ::mlflow::SetTag* Arena::CreateMaybeMessage<::mlflow::SetTag>(Arena*);
template<> ::mlflow::SetTag_Response* Arena::CreateMaybeMessage<::mlflow::SetTag_Response>(Arena*);
template<> ::mlflow::StringClause* Arena::CreateMaybeMessage<::mlflow::StringClause>(Arena*);
template<> ::mlflow::UpdateRun* Arena::CreateMaybeMessage<::mlflow::UpdateRun>(Arena*);
template<> ::mlflow::UpdateRun_Response* Arena::CreateMaybeMessage<::mlflow::UpdateRun_Response>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace mlflow {

enum ViewType {
  ACTIVE_ONLY = 1,
  DELETED_ONLY = 2,
  ALL = 3
};
bool ViewType_IsValid(int value);
const ViewType ViewType_MIN = ACTIVE_ONLY;
const ViewType ViewType_MAX = ALL;
const int ViewType_ARRAYSIZE = ViewType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ViewType_descriptor();
inline const ::std::string& ViewType_Name(ViewType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ViewType_descriptor(), value);
}
inline bool ViewType_Parse(
    const ::std::string& name, ViewType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ViewType>(
    ViewType_descriptor(), name, value);
}
enum SourceType {
  NOTEBOOK = 1,
  JOB = 2,
  PROJECT = 3,
  LOCAL = 4,
  UNKNOWN = 1000
};
bool SourceType_IsValid(int value);
const SourceType SourceType_MIN = NOTEBOOK;
const SourceType SourceType_MAX = UNKNOWN;
const int SourceType_ARRAYSIZE = SourceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SourceType_descriptor();
inline const ::std::string& SourceType_Name(SourceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SourceType_descriptor(), value);
}
inline bool SourceType_Parse(
    const ::std::string& name, SourceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SourceType>(
    SourceType_descriptor(), name, value);
}
enum RunStatus {
  RUNNING = 1,
  SCHEDULED = 2,
  FINISHED = 3,
  FAILED = 4,
  KILLED = 5
};
bool RunStatus_IsValid(int value);
const RunStatus RunStatus_MIN = RUNNING;
const RunStatus RunStatus_MAX = KILLED;
const int RunStatus_ARRAYSIZE = RunStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* RunStatus_descriptor();
inline const ::std::string& RunStatus_Name(RunStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    RunStatus_descriptor(), value);
}
inline bool RunStatus_Parse(
    const ::std::string& name, RunStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RunStatus>(
    RunStatus_descriptor(), name, value);
}
// ===================================================================

class Metric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.Metric) */ {
 public:
  Metric();
  virtual ~Metric();

  Metric(const Metric& from);

  inline Metric& operator=(const Metric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Metric(Metric&& from) noexcept
    : Metric() {
    *this = ::std::move(from);
  }

  inline Metric& operator=(Metric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Metric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Metric* internal_default_instance() {
    return reinterpret_cast<const Metric*>(
               &_Metric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Metric* other);
  friend void swap(Metric& a, Metric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Metric* New() const final {
    return CreateMaybeMessage<Metric>(NULL);
  }

  Metric* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Metric>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Metric& from);
  void MergeFrom(const Metric& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Metric* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional double value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // optional int64 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.Metric)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  double value_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Param : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.Param) */ {
 public:
  Param();
  virtual ~Param();

  Param(const Param& from);

  inline Param& operator=(const Param& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Param(Param&& from) noexcept
    : Param() {
    *this = ::std::move(from);
  }

  inline Param& operator=(Param&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Param& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Param* internal_default_instance() {
    return reinterpret_cast<const Param*>(
               &_Param_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Param* other);
  friend void swap(Param& a, Param& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Param* New() const final {
    return CreateMaybeMessage<Param>(NULL);
  }

  Param* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Param>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Param& from);
  void MergeFrom(const Param& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Param* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mlflow.Param)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Run : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.Run) */ {
 public:
  Run();
  virtual ~Run();

  Run(const Run& from);

  inline Run& operator=(const Run& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Run(Run&& from) noexcept
    : Run() {
    *this = ::std::move(from);
  }

  inline Run& operator=(Run&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Run& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Run* internal_default_instance() {
    return reinterpret_cast<const Run*>(
               &_Run_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Run* other);
  friend void swap(Run& a, Run& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Run* New() const final {
    return CreateMaybeMessage<Run>(NULL);
  }

  Run* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Run>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Run& from);
  void MergeFrom(const Run& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Run* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.RunInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  private:
  const ::mlflow::RunInfo& _internal_info() const;
  public:
  const ::mlflow::RunInfo& info() const;
  ::mlflow::RunInfo* release_info();
  ::mlflow::RunInfo* mutable_info();
  void set_allocated_info(::mlflow::RunInfo* info);

  // optional .mlflow.RunData data = 2;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 2;
  private:
  const ::mlflow::RunData& _internal_data() const;
  public:
  const ::mlflow::RunData& data() const;
  ::mlflow::RunData* release_data();
  ::mlflow::RunData* mutable_data();
  void set_allocated_data(::mlflow::RunData* data);

  // @@protoc_insertion_point(class_scope:mlflow.Run)
 private:
  void set_has_info();
  void clear_has_info();
  void set_has_data();
  void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mlflow::RunInfo* info_;
  ::mlflow::RunData* data_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RunData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RunData) */ {
 public:
  RunData();
  virtual ~RunData();

  RunData(const RunData& from);

  inline RunData& operator=(const RunData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunData(RunData&& from) noexcept
    : RunData() {
    *this = ::std::move(from);
  }

  inline RunData& operator=(RunData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunData& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunData* internal_default_instance() {
    return reinterpret_cast<const RunData*>(
               &_RunData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RunData* other);
  friend void swap(RunData& a, RunData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunData* New() const final {
    return CreateMaybeMessage<RunData>(NULL);
  }

  RunData* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunData>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunData& from);
  void MergeFrom(const RunData& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mlflow.Metric metrics = 1;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 1;
  ::mlflow::Metric* mutable_metrics(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >*
      mutable_metrics();
  const ::mlflow::Metric& metrics(int index) const;
  ::mlflow::Metric* add_metrics();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >&
      metrics() const;

  // repeated .mlflow.Param params = 2;
  int params_size() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  ::mlflow::Param* mutable_params(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::Param >*
      mutable_params();
  const ::mlflow::Param& params(int index) const;
  ::mlflow::Param* add_params();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::Param >&
      params() const;

  // repeated .mlflow.RunTag tags = 3;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 3;
  ::mlflow::RunTag* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >*
      mutable_tags();
  const ::mlflow::RunTag& tags(int index) const;
  ::mlflow::RunTag* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >&
      tags() const;

  // @@protoc_insertion_point(class_scope:mlflow.RunData)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::Metric > metrics_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::Param > params_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag > tags_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RunTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RunTag) */ {
 public:
  RunTag();
  virtual ~RunTag();

  RunTag(const RunTag& from);

  inline RunTag& operator=(const RunTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunTag(RunTag&& from) noexcept
    : RunTag() {
    *this = ::std::move(from);
  }

  inline RunTag& operator=(RunTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunTag* internal_default_instance() {
    return reinterpret_cast<const RunTag*>(
               &_RunTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RunTag* other);
  friend void swap(RunTag& a, RunTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunTag* New() const final {
    return CreateMaybeMessage<RunTag>(NULL);
  }

  RunTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunTag& from);
  void MergeFrom(const RunTag& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mlflow.RunTag)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RunInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RunInfo) */ {
 public:
  RunInfo();
  virtual ~RunInfo();

  RunInfo(const RunInfo& from);

  inline RunInfo& operator=(const RunInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RunInfo(RunInfo&& from) noexcept
    : RunInfo() {
    *this = ::std::move(from);
  }

  inline RunInfo& operator=(RunInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RunInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RunInfo* internal_default_instance() {
    return reinterpret_cast<const RunInfo*>(
               &_RunInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RunInfo* other);
  friend void swap(RunInfo& a, RunInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RunInfo* New() const final {
    return CreateMaybeMessage<RunInfo>(NULL);
  }

  RunInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RunInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RunInfo& from);
  void MergeFrom(const RunInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RunInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1;
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string source_name = 5;
  bool has_source_name() const;
  void clear_source_name();
  static const int kSourceNameFieldNumber = 5;
  const ::std::string& source_name() const;
  void set_source_name(const ::std::string& value);
  #if LANG_CXX11
  void set_source_name(::std::string&& value);
  #endif
  void set_source_name(const char* value);
  void set_source_name(const char* value, size_t size);
  ::std::string* mutable_source_name();
  ::std::string* release_source_name();
  void set_allocated_source_name(::std::string* source_name);

  // optional string user_id = 6;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 6;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional string source_version = 10;
  bool has_source_version() const;
  void clear_source_version();
  static const int kSourceVersionFieldNumber = 10;
  const ::std::string& source_version() const;
  void set_source_version(const ::std::string& value);
  #if LANG_CXX11
  void set_source_version(::std::string&& value);
  #endif
  void set_source_version(const char* value);
  void set_source_version(const char* value, size_t size);
  ::std::string* mutable_source_version();
  ::std::string* release_source_version();
  void set_allocated_source_version(::std::string* source_version);

  // optional string entry_point_name = 11;
  bool has_entry_point_name() const;
  void clear_entry_point_name();
  static const int kEntryPointNameFieldNumber = 11;
  const ::std::string& entry_point_name() const;
  void set_entry_point_name(const ::std::string& value);
  #if LANG_CXX11
  void set_entry_point_name(::std::string&& value);
  #endif
  void set_entry_point_name(const char* value);
  void set_entry_point_name(const char* value, size_t size);
  ::std::string* mutable_entry_point_name();
  ::std::string* release_entry_point_name();
  void set_allocated_entry_point_name(::std::string* entry_point_name);

  // optional string artifact_uri = 13;
  bool has_artifact_uri() const;
  void clear_artifact_uri();
  static const int kArtifactUriFieldNumber = 13;
  const ::std::string& artifact_uri() const;
  void set_artifact_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_artifact_uri(::std::string&& value);
  #endif
  void set_artifact_uri(const char* value);
  void set_artifact_uri(const char* value, size_t size);
  ::std::string* mutable_artifact_uri();
  ::std::string* release_artifact_uri();
  void set_allocated_artifact_uri(::std::string* artifact_uri);

  // optional string lifecycle_stage = 14;
  bool has_lifecycle_stage() const;
  void clear_lifecycle_stage();
  static const int kLifecycleStageFieldNumber = 14;
  const ::std::string& lifecycle_stage() const;
  void set_lifecycle_stage(const ::std::string& value);
  #if LANG_CXX11
  void set_lifecycle_stage(::std::string&& value);
  #endif
  void set_lifecycle_stage(const char* value);
  void set_lifecycle_stage(const char* value, size_t size);
  ::std::string* mutable_lifecycle_stage();
  ::std::string* release_lifecycle_stage();
  void set_allocated_lifecycle_stage(::std::string* lifecycle_stage);

  // optional int64 experiment_id = 2;
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 2;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // optional int64 start_time = 8;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 8;
  ::google::protobuf::int64 start_time() const;
  void set_start_time(::google::protobuf::int64 value);

  // optional int64 end_time = 9;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 9;
  ::google::protobuf::int64 end_time() const;
  void set_end_time(::google::protobuf::int64 value);

  // optional .mlflow.SourceType source_type = 4;
  bool has_source_type() const;
  void clear_source_type();
  static const int kSourceTypeFieldNumber = 4;
  ::mlflow::SourceType source_type() const;
  void set_source_type(::mlflow::SourceType value);

  // optional .mlflow.RunStatus status = 7;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 7;
  ::mlflow::RunStatus status() const;
  void set_status(::mlflow::RunStatus value);

  // @@protoc_insertion_point(class_scope:mlflow.RunInfo)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_experiment_id();
  void clear_has_experiment_id();
  void set_has_name();
  void clear_has_name();
  void set_has_source_type();
  void clear_has_source_type();
  void set_has_source_name();
  void clear_has_source_name();
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_status();
  void clear_has_status();
  void set_has_start_time();
  void clear_has_start_time();
  void set_has_end_time();
  void clear_has_end_time();
  void set_has_source_version();
  void clear_has_source_version();
  void set_has_entry_point_name();
  void clear_has_entry_point_name();
  void set_has_artifact_uri();
  void clear_has_artifact_uri();
  void set_has_lifecycle_stage();
  void clear_has_lifecycle_stage();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr source_name_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr source_version_;
  ::google::protobuf::internal::ArenaStringPtr entry_point_name_;
  ::google::protobuf::internal::ArenaStringPtr artifact_uri_;
  ::google::protobuf::internal::ArenaStringPtr lifecycle_stage_;
  ::google::protobuf::int64 experiment_id_;
  ::google::protobuf::int64 start_time_;
  ::google::protobuf::int64 end_time_;
  int source_type_;
  int status_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Experiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.Experiment) */ {
 public:
  Experiment();
  virtual ~Experiment();

  Experiment(const Experiment& from);

  inline Experiment& operator=(const Experiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Experiment(Experiment&& from) noexcept
    : Experiment() {
    *this = ::std::move(from);
  }

  inline Experiment& operator=(Experiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Experiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Experiment* internal_default_instance() {
    return reinterpret_cast<const Experiment*>(
               &_Experiment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Experiment* other);
  friend void swap(Experiment& a, Experiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Experiment* New() const final {
    return CreateMaybeMessage<Experiment>(NULL);
  }

  Experiment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Experiment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Experiment& from);
  void MergeFrom(const Experiment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Experiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string artifact_location = 3;
  bool has_artifact_location() const;
  void clear_artifact_location();
  static const int kArtifactLocationFieldNumber = 3;
  const ::std::string& artifact_location() const;
  void set_artifact_location(const ::std::string& value);
  #if LANG_CXX11
  void set_artifact_location(::std::string&& value);
  #endif
  void set_artifact_location(const char* value);
  void set_artifact_location(const char* value, size_t size);
  ::std::string* mutable_artifact_location();
  ::std::string* release_artifact_location();
  void set_allocated_artifact_location(::std::string* artifact_location);

  // optional string lifecycle_stage = 4;
  bool has_lifecycle_stage() const;
  void clear_lifecycle_stage();
  static const int kLifecycleStageFieldNumber = 4;
  const ::std::string& lifecycle_stage() const;
  void set_lifecycle_stage(const ::std::string& value);
  #if LANG_CXX11
  void set_lifecycle_stage(::std::string&& value);
  #endif
  void set_lifecycle_stage(const char* value);
  void set_lifecycle_stage(const char* value, size_t size);
  ::std::string* mutable_lifecycle_stage();
  ::std::string* release_lifecycle_stage();
  void set_allocated_lifecycle_stage(::std::string* lifecycle_stage);

  // optional int64 experiment_id = 1;
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // optional int64 last_update_time = 5;
  bool has_last_update_time() const;
  void clear_last_update_time();
  static const int kLastUpdateTimeFieldNumber = 5;
  ::google::protobuf::int64 last_update_time() const;
  void set_last_update_time(::google::protobuf::int64 value);

  // optional int64 creation_time = 6;
  bool has_creation_time() const;
  void clear_creation_time();
  static const int kCreationTimeFieldNumber = 6;
  ::google::protobuf::int64 creation_time() const;
  void set_creation_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.Experiment)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();
  void set_has_name();
  void clear_has_name();
  void set_has_artifact_location();
  void clear_has_artifact_location();
  void set_has_lifecycle_stage();
  void clear_has_lifecycle_stage();
  void set_has_last_update_time();
  void clear_has_last_update_time();
  void set_has_creation_time();
  void clear_has_creation_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr artifact_location_;
  ::google::protobuf::internal::ArenaStringPtr lifecycle_stage_;
  ::google::protobuf::int64 experiment_id_;
  ::google::protobuf::int64 last_update_time_;
  ::google::protobuf::int64 creation_time_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateExperiment_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.CreateExperiment.Response) */ {
 public:
  CreateExperiment_Response();
  virtual ~CreateExperiment_Response();

  CreateExperiment_Response(const CreateExperiment_Response& from);

  inline CreateExperiment_Response& operator=(const CreateExperiment_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateExperiment_Response(CreateExperiment_Response&& from) noexcept
    : CreateExperiment_Response() {
    *this = ::std::move(from);
  }

  inline CreateExperiment_Response& operator=(CreateExperiment_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateExperiment_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateExperiment_Response* internal_default_instance() {
    return reinterpret_cast<const CreateExperiment_Response*>(
               &_CreateExperiment_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(CreateExperiment_Response* other);
  friend void swap(CreateExperiment_Response& a, CreateExperiment_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateExperiment_Response* New() const final {
    return CreateMaybeMessage<CreateExperiment_Response>(NULL);
  }

  CreateExperiment_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateExperiment_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateExperiment_Response& from);
  void MergeFrom(const CreateExperiment_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateExperiment_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 experiment_id = 1;
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.CreateExperiment.Response)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 experiment_id_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateExperiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.CreateExperiment) */ {
 public:
  CreateExperiment();
  virtual ~CreateExperiment();

  CreateExperiment(const CreateExperiment& from);

  inline CreateExperiment& operator=(const CreateExperiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateExperiment(CreateExperiment&& from) noexcept
    : CreateExperiment() {
    *this = ::std::move(from);
  }

  inline CreateExperiment& operator=(CreateExperiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateExperiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateExperiment* internal_default_instance() {
    return reinterpret_cast<const CreateExperiment*>(
               &_CreateExperiment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(CreateExperiment* other);
  friend void swap(CreateExperiment& a, CreateExperiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateExperiment* New() const final {
    return CreateMaybeMessage<CreateExperiment>(NULL);
  }

  CreateExperiment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateExperiment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateExperiment& from);
  void MergeFrom(const CreateExperiment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateExperiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateExperiment_Response Response;

  // accessors -------------------------------------------------------

  // optional string name = 1 [(.validate_required) = true];
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string artifact_location = 5;
  bool has_artifact_location() const;
  void clear_artifact_location();
  static const int kArtifactLocationFieldNumber = 5;
  const ::std::string& artifact_location() const;
  void set_artifact_location(const ::std::string& value);
  #if LANG_CXX11
  void set_artifact_location(::std::string&& value);
  #endif
  void set_artifact_location(const char* value);
  void set_artifact_location(const char* value, size_t size);
  ::std::string* mutable_artifact_location();
  ::std::string* release_artifact_location();
  void set_allocated_artifact_location(::std::string* artifact_location);

  // @@protoc_insertion_point(class_scope:mlflow.CreateExperiment)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_artifact_location();
  void clear_has_artifact_location();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr artifact_location_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListExperiments_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.ListExperiments.Response) */ {
 public:
  ListExperiments_Response();
  virtual ~ListExperiments_Response();

  ListExperiments_Response(const ListExperiments_Response& from);

  inline ListExperiments_Response& operator=(const ListExperiments_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListExperiments_Response(ListExperiments_Response&& from) noexcept
    : ListExperiments_Response() {
    *this = ::std::move(from);
  }

  inline ListExperiments_Response& operator=(ListExperiments_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListExperiments_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListExperiments_Response* internal_default_instance() {
    return reinterpret_cast<const ListExperiments_Response*>(
               &_ListExperiments_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ListExperiments_Response* other);
  friend void swap(ListExperiments_Response& a, ListExperiments_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListExperiments_Response* New() const final {
    return CreateMaybeMessage<ListExperiments_Response>(NULL);
  }

  ListExperiments_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListExperiments_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListExperiments_Response& from);
  void MergeFrom(const ListExperiments_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListExperiments_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mlflow.Experiment experiments = 1;
  int experiments_size() const;
  void clear_experiments();
  static const int kExperimentsFieldNumber = 1;
  ::mlflow::Experiment* mutable_experiments(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::Experiment >*
      mutable_experiments();
  const ::mlflow::Experiment& experiments(int index) const;
  ::mlflow::Experiment* add_experiments();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::Experiment >&
      experiments() const;

  // @@protoc_insertion_point(class_scope:mlflow.ListExperiments.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::Experiment > experiments_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListExperiments : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.ListExperiments) */ {
 public:
  ListExperiments();
  virtual ~ListExperiments();

  ListExperiments(const ListExperiments& from);

  inline ListExperiments& operator=(const ListExperiments& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListExperiments(ListExperiments&& from) noexcept
    : ListExperiments() {
    *this = ::std::move(from);
  }

  inline ListExperiments& operator=(ListExperiments&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListExperiments& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListExperiments* internal_default_instance() {
    return reinterpret_cast<const ListExperiments*>(
               &_ListExperiments_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ListExperiments* other);
  friend void swap(ListExperiments& a, ListExperiments& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListExperiments* New() const final {
    return CreateMaybeMessage<ListExperiments>(NULL);
  }

  ListExperiments* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListExperiments>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListExperiments& from);
  void MergeFrom(const ListExperiments& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListExperiments* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListExperiments_Response Response;

  // accessors -------------------------------------------------------

  // optional .mlflow.ViewType view_type = 1;
  bool has_view_type() const;
  void clear_view_type();
  static const int kViewTypeFieldNumber = 1;
  ::mlflow::ViewType view_type() const;
  void set_view_type(::mlflow::ViewType value);

  // @@protoc_insertion_point(class_scope:mlflow.ListExperiments)
 private:
  void set_has_view_type();
  void clear_has_view_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  int view_type_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetExperiment_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetExperiment.Response) */ {
 public:
  GetExperiment_Response();
  virtual ~GetExperiment_Response();

  GetExperiment_Response(const GetExperiment_Response& from);

  inline GetExperiment_Response& operator=(const GetExperiment_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetExperiment_Response(GetExperiment_Response&& from) noexcept
    : GetExperiment_Response() {
    *this = ::std::move(from);
  }

  inline GetExperiment_Response& operator=(GetExperiment_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetExperiment_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetExperiment_Response* internal_default_instance() {
    return reinterpret_cast<const GetExperiment_Response*>(
               &_GetExperiment_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetExperiment_Response* other);
  friend void swap(GetExperiment_Response& a, GetExperiment_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetExperiment_Response* New() const final {
    return CreateMaybeMessage<GetExperiment_Response>(NULL);
  }

  GetExperiment_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetExperiment_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetExperiment_Response& from);
  void MergeFrom(const GetExperiment_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExperiment_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mlflow.RunInfo runs = 2;
  int runs_size() const;
  void clear_runs();
  static const int kRunsFieldNumber = 2;
  ::mlflow::RunInfo* mutable_runs(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::RunInfo >*
      mutable_runs();
  const ::mlflow::RunInfo& runs(int index) const;
  ::mlflow::RunInfo* add_runs();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::RunInfo >&
      runs() const;

  // optional .mlflow.Experiment experiment = 1;
  bool has_experiment() const;
  void clear_experiment();
  static const int kExperimentFieldNumber = 1;
  private:
  const ::mlflow::Experiment& _internal_experiment() const;
  public:
  const ::mlflow::Experiment& experiment() const;
  ::mlflow::Experiment* release_experiment();
  ::mlflow::Experiment* mutable_experiment();
  void set_allocated_experiment(::mlflow::Experiment* experiment);

  // @@protoc_insertion_point(class_scope:mlflow.GetExperiment.Response)
 private:
  void set_has_experiment();
  void clear_has_experiment();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::RunInfo > runs_;
  ::mlflow::Experiment* experiment_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetExperiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetExperiment) */ {
 public:
  GetExperiment();
  virtual ~GetExperiment();

  GetExperiment(const GetExperiment& from);

  inline GetExperiment& operator=(const GetExperiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetExperiment(GetExperiment&& from) noexcept
    : GetExperiment() {
    *this = ::std::move(from);
  }

  inline GetExperiment& operator=(GetExperiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetExperiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetExperiment* internal_default_instance() {
    return reinterpret_cast<const GetExperiment*>(
               &_GetExperiment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetExperiment* other);
  friend void swap(GetExperiment& a, GetExperiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetExperiment* New() const final {
    return CreateMaybeMessage<GetExperiment>(NULL);
  }

  GetExperiment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetExperiment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetExperiment& from);
  void MergeFrom(const GetExperiment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExperiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetExperiment_Response Response;

  // accessors -------------------------------------------------------

  // optional int64 experiment_id = 1 [(.validate_required) = true];
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.GetExperiment)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 experiment_id_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteExperiment_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.DeleteExperiment.Response) */ {
 public:
  DeleteExperiment_Response();
  virtual ~DeleteExperiment_Response();

  DeleteExperiment_Response(const DeleteExperiment_Response& from);

  inline DeleteExperiment_Response& operator=(const DeleteExperiment_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteExperiment_Response(DeleteExperiment_Response&& from) noexcept
    : DeleteExperiment_Response() {
    *this = ::std::move(from);
  }

  inline DeleteExperiment_Response& operator=(DeleteExperiment_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteExperiment_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteExperiment_Response* internal_default_instance() {
    return reinterpret_cast<const DeleteExperiment_Response*>(
               &_DeleteExperiment_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(DeleteExperiment_Response* other);
  friend void swap(DeleteExperiment_Response& a, DeleteExperiment_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteExperiment_Response* New() const final {
    return CreateMaybeMessage<DeleteExperiment_Response>(NULL);
  }

  DeleteExperiment_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteExperiment_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteExperiment_Response& from);
  void MergeFrom(const DeleteExperiment_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteExperiment_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.DeleteExperiment.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteExperiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.DeleteExperiment) */ {
 public:
  DeleteExperiment();
  virtual ~DeleteExperiment();

  DeleteExperiment(const DeleteExperiment& from);

  inline DeleteExperiment& operator=(const DeleteExperiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteExperiment(DeleteExperiment&& from) noexcept
    : DeleteExperiment() {
    *this = ::std::move(from);
  }

  inline DeleteExperiment& operator=(DeleteExperiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteExperiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteExperiment* internal_default_instance() {
    return reinterpret_cast<const DeleteExperiment*>(
               &_DeleteExperiment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(DeleteExperiment* other);
  friend void swap(DeleteExperiment& a, DeleteExperiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteExperiment* New() const final {
    return CreateMaybeMessage<DeleteExperiment>(NULL);
  }

  DeleteExperiment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteExperiment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteExperiment& from);
  void MergeFrom(const DeleteExperiment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteExperiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeleteExperiment_Response Response;

  // accessors -------------------------------------------------------

  // optional int64 experiment_id = 1 [(.validate_required) = true];
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.DeleteExperiment)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 experiment_id_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestoreExperiment_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RestoreExperiment.Response) */ {
 public:
  RestoreExperiment_Response();
  virtual ~RestoreExperiment_Response();

  RestoreExperiment_Response(const RestoreExperiment_Response& from);

  inline RestoreExperiment_Response& operator=(const RestoreExperiment_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RestoreExperiment_Response(RestoreExperiment_Response&& from) noexcept
    : RestoreExperiment_Response() {
    *this = ::std::move(from);
  }

  inline RestoreExperiment_Response& operator=(RestoreExperiment_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestoreExperiment_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestoreExperiment_Response* internal_default_instance() {
    return reinterpret_cast<const RestoreExperiment_Response*>(
               &_RestoreExperiment_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RestoreExperiment_Response* other);
  friend void swap(RestoreExperiment_Response& a, RestoreExperiment_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RestoreExperiment_Response* New() const final {
    return CreateMaybeMessage<RestoreExperiment_Response>(NULL);
  }

  RestoreExperiment_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RestoreExperiment_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RestoreExperiment_Response& from);
  void MergeFrom(const RestoreExperiment_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreExperiment_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.RestoreExperiment.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestoreExperiment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RestoreExperiment) */ {
 public:
  RestoreExperiment();
  virtual ~RestoreExperiment();

  RestoreExperiment(const RestoreExperiment& from);

  inline RestoreExperiment& operator=(const RestoreExperiment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RestoreExperiment(RestoreExperiment&& from) noexcept
    : RestoreExperiment() {
    *this = ::std::move(from);
  }

  inline RestoreExperiment& operator=(RestoreExperiment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestoreExperiment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestoreExperiment* internal_default_instance() {
    return reinterpret_cast<const RestoreExperiment*>(
               &_RestoreExperiment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RestoreExperiment* other);
  friend void swap(RestoreExperiment& a, RestoreExperiment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RestoreExperiment* New() const final {
    return CreateMaybeMessage<RestoreExperiment>(NULL);
  }

  RestoreExperiment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RestoreExperiment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RestoreExperiment& from);
  void MergeFrom(const RestoreExperiment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreExperiment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RestoreExperiment_Response Response;

  // accessors -------------------------------------------------------

  // optional int64 experiment_id = 1 [(.validate_required) = true];
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.RestoreExperiment)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 experiment_id_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateRun_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.CreateRun.Response) */ {
 public:
  CreateRun_Response();
  virtual ~CreateRun_Response();

  CreateRun_Response(const CreateRun_Response& from);

  inline CreateRun_Response& operator=(const CreateRun_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRun_Response(CreateRun_Response&& from) noexcept
    : CreateRun_Response() {
    *this = ::std::move(from);
  }

  inline CreateRun_Response& operator=(CreateRun_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRun_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRun_Response* internal_default_instance() {
    return reinterpret_cast<const CreateRun_Response*>(
               &_CreateRun_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(CreateRun_Response* other);
  friend void swap(CreateRun_Response& a, CreateRun_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRun_Response* New() const final {
    return CreateMaybeMessage<CreateRun_Response>(NULL);
  }

  CreateRun_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateRun_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateRun_Response& from);
  void MergeFrom(const CreateRun_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRun_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.Run run = 1;
  bool has_run() const;
  void clear_run();
  static const int kRunFieldNumber = 1;
  private:
  const ::mlflow::Run& _internal_run() const;
  public:
  const ::mlflow::Run& run() const;
  ::mlflow::Run* release_run();
  ::mlflow::Run* mutable_run();
  void set_allocated_run(::mlflow::Run* run);

  // @@protoc_insertion_point(class_scope:mlflow.CreateRun.Response)
 private:
  void set_has_run();
  void clear_has_run();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mlflow::Run* run_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateRun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.CreateRun) */ {
 public:
  CreateRun();
  virtual ~CreateRun();

  CreateRun(const CreateRun& from);

  inline CreateRun& operator=(const CreateRun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateRun(CreateRun&& from) noexcept
    : CreateRun() {
    *this = ::std::move(from);
  }

  inline CreateRun& operator=(CreateRun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateRun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateRun* internal_default_instance() {
    return reinterpret_cast<const CreateRun*>(
               &_CreateRun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(CreateRun* other);
  friend void swap(CreateRun& a, CreateRun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateRun* New() const final {
    return CreateMaybeMessage<CreateRun>(NULL);
  }

  CreateRun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateRun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateRun& from);
  void MergeFrom(const CreateRun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateRun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CreateRun_Response Response;

  // accessors -------------------------------------------------------

  // repeated .mlflow.RunTag tags = 9;
  int tags_size() const;
  void clear_tags();
  static const int kTagsFieldNumber = 9;
  ::mlflow::RunTag* mutable_tags(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >*
      mutable_tags();
  const ::mlflow::RunTag& tags(int index) const;
  ::mlflow::RunTag* add_tags();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >&
      tags() const;

  // optional string user_id = 2;
  bool has_user_id() const;
  void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  const ::std::string& user_id() const;
  void set_user_id(const ::std::string& value);
  #if LANG_CXX11
  void set_user_id(::std::string&& value);
  #endif
  void set_user_id(const char* value);
  void set_user_id(const char* value, size_t size);
  ::std::string* mutable_user_id();
  ::std::string* release_user_id();
  void set_allocated_user_id(::std::string* user_id);

  // optional string run_name = 3;
  bool has_run_name() const;
  void clear_run_name();
  static const int kRunNameFieldNumber = 3;
  const ::std::string& run_name() const;
  void set_run_name(const ::std::string& value);
  #if LANG_CXX11
  void set_run_name(::std::string&& value);
  #endif
  void set_run_name(const char* value);
  void set_run_name(const char* value, size_t size);
  ::std::string* mutable_run_name();
  ::std::string* release_run_name();
  void set_allocated_run_name(::std::string* run_name);

  // optional string source_name = 5;
  bool has_source_name() const;
  void clear_source_name();
  static const int kSourceNameFieldNumber = 5;
  const ::std::string& source_name() const;
  void set_source_name(const ::std::string& value);
  #if LANG_CXX11
  void set_source_name(::std::string&& value);
  #endif
  void set_source_name(const char* value);
  void set_source_name(const char* value, size_t size);
  ::std::string* mutable_source_name();
  ::std::string* release_source_name();
  void set_allocated_source_name(::std::string* source_name);

  // optional string entry_point_name = 6;
  bool has_entry_point_name() const;
  void clear_entry_point_name();
  static const int kEntryPointNameFieldNumber = 6;
  const ::std::string& entry_point_name() const;
  void set_entry_point_name(const ::std::string& value);
  #if LANG_CXX11
  void set_entry_point_name(::std::string&& value);
  #endif
  void set_entry_point_name(const char* value);
  void set_entry_point_name(const char* value, size_t size);
  ::std::string* mutable_entry_point_name();
  ::std::string* release_entry_point_name();
  void set_allocated_entry_point_name(::std::string* entry_point_name);

  // optional string source_version = 8;
  bool has_source_version() const;
  void clear_source_version();
  static const int kSourceVersionFieldNumber = 8;
  const ::std::string& source_version() const;
  void set_source_version(const ::std::string& value);
  #if LANG_CXX11
  void set_source_version(::std::string&& value);
  #endif
  void set_source_version(const char* value);
  void set_source_version(const char* value, size_t size);
  ::std::string* mutable_source_version();
  ::std::string* release_source_version();
  void set_allocated_source_version(::std::string* source_version);

  // optional string parent_run_id = 10;
  bool has_parent_run_id() const;
  void clear_parent_run_id();
  static const int kParentRunIdFieldNumber = 10;
  const ::std::string& parent_run_id() const;
  void set_parent_run_id(const ::std::string& value);
  #if LANG_CXX11
  void set_parent_run_id(::std::string&& value);
  #endif
  void set_parent_run_id(const char* value);
  void set_parent_run_id(const char* value, size_t size);
  ::std::string* mutable_parent_run_id();
  ::std::string* release_parent_run_id();
  void set_allocated_parent_run_id(::std::string* parent_run_id);

  // optional int64 experiment_id = 1;
  bool has_experiment_id() const;
  void clear_experiment_id();
  static const int kExperimentIdFieldNumber = 1;
  ::google::protobuf::int64 experiment_id() const;
  void set_experiment_id(::google::protobuf::int64 value);

  // optional int64 start_time = 7;
  bool has_start_time() const;
  void clear_start_time();
  static const int kStartTimeFieldNumber = 7;
  ::google::protobuf::int64 start_time() const;
  void set_start_time(::google::protobuf::int64 value);

  // optional .mlflow.SourceType source_type = 4;
  bool has_source_type() const;
  void clear_source_type();
  static const int kSourceTypeFieldNumber = 4;
  ::mlflow::SourceType source_type() const;
  void set_source_type(::mlflow::SourceType value);

  // @@protoc_insertion_point(class_scope:mlflow.CreateRun)
 private:
  void set_has_experiment_id();
  void clear_has_experiment_id();
  void set_has_user_id();
  void clear_has_user_id();
  void set_has_run_name();
  void clear_has_run_name();
  void set_has_source_type();
  void clear_has_source_type();
  void set_has_source_name();
  void clear_has_source_name();
  void set_has_entry_point_name();
  void clear_has_entry_point_name();
  void set_has_start_time();
  void clear_has_start_time();
  void set_has_source_version();
  void clear_has_source_version();
  void set_has_parent_run_id();
  void clear_has_parent_run_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag > tags_;
  ::google::protobuf::internal::ArenaStringPtr user_id_;
  ::google::protobuf::internal::ArenaStringPtr run_name_;
  ::google::protobuf::internal::ArenaStringPtr source_name_;
  ::google::protobuf::internal::ArenaStringPtr entry_point_name_;
  ::google::protobuf::internal::ArenaStringPtr source_version_;
  ::google::protobuf::internal::ArenaStringPtr parent_run_id_;
  ::google::protobuf::int64 experiment_id_;
  ::google::protobuf::int64 start_time_;
  int source_type_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateRun_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.UpdateRun.Response) */ {
 public:
  UpdateRun_Response();
  virtual ~UpdateRun_Response();

  UpdateRun_Response(const UpdateRun_Response& from);

  inline UpdateRun_Response& operator=(const UpdateRun_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRun_Response(UpdateRun_Response&& from) noexcept
    : UpdateRun_Response() {
    *this = ::std::move(from);
  }

  inline UpdateRun_Response& operator=(UpdateRun_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRun_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRun_Response* internal_default_instance() {
    return reinterpret_cast<const UpdateRun_Response*>(
               &_UpdateRun_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(UpdateRun_Response* other);
  friend void swap(UpdateRun_Response& a, UpdateRun_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRun_Response* New() const final {
    return CreateMaybeMessage<UpdateRun_Response>(NULL);
  }

  UpdateRun_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRun_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateRun_Response& from);
  void MergeFrom(const UpdateRun_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRun_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.RunInfo run_info = 1;
  bool has_run_info() const;
  void clear_run_info();
  static const int kRunInfoFieldNumber = 1;
  private:
  const ::mlflow::RunInfo& _internal_run_info() const;
  public:
  const ::mlflow::RunInfo& run_info() const;
  ::mlflow::RunInfo* release_run_info();
  ::mlflow::RunInfo* mutable_run_info();
  void set_allocated_run_info(::mlflow::RunInfo* run_info);

  // @@protoc_insertion_point(class_scope:mlflow.UpdateRun.Response)
 private:
  void set_has_run_info();
  void clear_has_run_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mlflow::RunInfo* run_info_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class UpdateRun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.UpdateRun) */ {
 public:
  UpdateRun();
  virtual ~UpdateRun();

  UpdateRun(const UpdateRun& from);

  inline UpdateRun& operator=(const UpdateRun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UpdateRun(UpdateRun&& from) noexcept
    : UpdateRun() {
    *this = ::std::move(from);
  }

  inline UpdateRun& operator=(UpdateRun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UpdateRun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UpdateRun* internal_default_instance() {
    return reinterpret_cast<const UpdateRun*>(
               &_UpdateRun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(UpdateRun* other);
  friend void swap(UpdateRun& a, UpdateRun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UpdateRun* New() const final {
    return CreateMaybeMessage<UpdateRun>(NULL);
  }

  UpdateRun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UpdateRun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UpdateRun& from);
  void MergeFrom(const UpdateRun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UpdateRun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef UpdateRun_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional int64 end_time = 3;
  bool has_end_time() const;
  void clear_end_time();
  static const int kEndTimeFieldNumber = 3;
  ::google::protobuf::int64 end_time() const;
  void set_end_time(::google::protobuf::int64 value);

  // optional .mlflow.RunStatus status = 2;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 2;
  ::mlflow::RunStatus status() const;
  void set_status(::mlflow::RunStatus value);

  // @@protoc_insertion_point(class_scope:mlflow.UpdateRun)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_status();
  void clear_has_status();
  void set_has_end_time();
  void clear_has_end_time();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::int64 end_time_;
  int status_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRun_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.DeleteRun.Response) */ {
 public:
  DeleteRun_Response();
  virtual ~DeleteRun_Response();

  DeleteRun_Response(const DeleteRun_Response& from);

  inline DeleteRun_Response& operator=(const DeleteRun_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRun_Response(DeleteRun_Response&& from) noexcept
    : DeleteRun_Response() {
    *this = ::std::move(from);
  }

  inline DeleteRun_Response& operator=(DeleteRun_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRun_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRun_Response* internal_default_instance() {
    return reinterpret_cast<const DeleteRun_Response*>(
               &_DeleteRun_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(DeleteRun_Response* other);
  friend void swap(DeleteRun_Response& a, DeleteRun_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRun_Response* New() const final {
    return CreateMaybeMessage<DeleteRun_Response>(NULL);
  }

  DeleteRun_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRun_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRun_Response& from);
  void MergeFrom(const DeleteRun_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRun_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.DeleteRun.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.DeleteRun) */ {
 public:
  DeleteRun();
  virtual ~DeleteRun();

  DeleteRun(const DeleteRun& from);

  inline DeleteRun& operator=(const DeleteRun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRun(DeleteRun&& from) noexcept
    : DeleteRun() {
    *this = ::std::move(from);
  }

  inline DeleteRun& operator=(DeleteRun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRun* internal_default_instance() {
    return reinterpret_cast<const DeleteRun*>(
               &_DeleteRun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(DeleteRun* other);
  friend void swap(DeleteRun& a, DeleteRun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRun* New() const final {
    return CreateMaybeMessage<DeleteRun>(NULL);
  }

  DeleteRun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRun& from);
  void MergeFrom(const DeleteRun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeleteRun_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_id = 1 [(.validate_required) = true];
  bool has_run_id() const;
  void clear_run_id();
  static const int kRunIdFieldNumber = 1;
  const ::std::string& run_id() const;
  void set_run_id(const ::std::string& value);
  #if LANG_CXX11
  void set_run_id(::std::string&& value);
  #endif
  void set_run_id(const char* value);
  void set_run_id(const char* value, size_t size);
  ::std::string* mutable_run_id();
  ::std::string* release_run_id();
  void set_allocated_run_id(::std::string* run_id);

  // @@protoc_insertion_point(class_scope:mlflow.DeleteRun)
 private:
  void set_has_run_id();
  void clear_has_run_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_id_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestoreRun_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RestoreRun.Response) */ {
 public:
  RestoreRun_Response();
  virtual ~RestoreRun_Response();

  RestoreRun_Response(const RestoreRun_Response& from);

  inline RestoreRun_Response& operator=(const RestoreRun_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RestoreRun_Response(RestoreRun_Response&& from) noexcept
    : RestoreRun_Response() {
    *this = ::std::move(from);
  }

  inline RestoreRun_Response& operator=(RestoreRun_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestoreRun_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestoreRun_Response* internal_default_instance() {
    return reinterpret_cast<const RestoreRun_Response*>(
               &_RestoreRun_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(RestoreRun_Response* other);
  friend void swap(RestoreRun_Response& a, RestoreRun_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RestoreRun_Response* New() const final {
    return CreateMaybeMessage<RestoreRun_Response>(NULL);
  }

  RestoreRun_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RestoreRun_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RestoreRun_Response& from);
  void MergeFrom(const RestoreRun_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreRun_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.RestoreRun.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RestoreRun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.RestoreRun) */ {
 public:
  RestoreRun();
  virtual ~RestoreRun();

  RestoreRun(const RestoreRun& from);

  inline RestoreRun& operator=(const RestoreRun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RestoreRun(RestoreRun&& from) noexcept
    : RestoreRun() {
    *this = ::std::move(from);
  }

  inline RestoreRun& operator=(RestoreRun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RestoreRun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RestoreRun* internal_default_instance() {
    return reinterpret_cast<const RestoreRun*>(
               &_RestoreRun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(RestoreRun* other);
  friend void swap(RestoreRun& a, RestoreRun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RestoreRun* New() const final {
    return CreateMaybeMessage<RestoreRun>(NULL);
  }

  RestoreRun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RestoreRun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RestoreRun& from);
  void MergeFrom(const RestoreRun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RestoreRun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef RestoreRun_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_id = 1 [(.validate_required) = true];
  bool has_run_id() const;
  void clear_run_id();
  static const int kRunIdFieldNumber = 1;
  const ::std::string& run_id() const;
  void set_run_id(const ::std::string& value);
  #if LANG_CXX11
  void set_run_id(::std::string&& value);
  #endif
  void set_run_id(const char* value);
  void set_run_id(const char* value, size_t size);
  ::std::string* mutable_run_id();
  ::std::string* release_run_id();
  void set_allocated_run_id(::std::string* run_id);

  // @@protoc_insertion_point(class_scope:mlflow.RestoreRun)
 private:
  void set_has_run_id();
  void clear_has_run_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_id_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogMetric_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.LogMetric.Response) */ {
 public:
  LogMetric_Response();
  virtual ~LogMetric_Response();

  LogMetric_Response(const LogMetric_Response& from);

  inline LogMetric_Response& operator=(const LogMetric_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogMetric_Response(LogMetric_Response&& from) noexcept
    : LogMetric_Response() {
    *this = ::std::move(from);
  }

  inline LogMetric_Response& operator=(LogMetric_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMetric_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogMetric_Response* internal_default_instance() {
    return reinterpret_cast<const LogMetric_Response*>(
               &_LogMetric_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(LogMetric_Response* other);
  friend void swap(LogMetric_Response& a, LogMetric_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogMetric_Response* New() const final {
    return CreateMaybeMessage<LogMetric_Response>(NULL);
  }

  LogMetric_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogMetric_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogMetric_Response& from);
  void MergeFrom(const LogMetric_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogMetric_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.LogMetric.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogMetric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.LogMetric) */ {
 public:
  LogMetric();
  virtual ~LogMetric();

  LogMetric(const LogMetric& from);

  inline LogMetric& operator=(const LogMetric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogMetric(LogMetric&& from) noexcept
    : LogMetric() {
    *this = ::std::move(from);
  }

  inline LogMetric& operator=(LogMetric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogMetric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogMetric* internal_default_instance() {
    return reinterpret_cast<const LogMetric*>(
               &_LogMetric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(LogMetric* other);
  friend void swap(LogMetric& a, LogMetric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogMetric* New() const final {
    return CreateMaybeMessage<LogMetric>(NULL);
  }

  LogMetric* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogMetric>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogMetric& from);
  void MergeFrom(const LogMetric& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogMetric* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogMetric_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string key = 2 [(.validate_required) = true];
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional double value = 3 [(.validate_required) = true];
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  double value() const;
  void set_value(double value);

  // optional int64 timestamp = 4 [(.validate_required) = true];
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::int64 timestamp() const;
  void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:mlflow.LogMetric)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  double value_;
  ::google::protobuf::int64 timestamp_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogParam_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.LogParam.Response) */ {
 public:
  LogParam_Response();
  virtual ~LogParam_Response();

  LogParam_Response(const LogParam_Response& from);

  inline LogParam_Response& operator=(const LogParam_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogParam_Response(LogParam_Response&& from) noexcept
    : LogParam_Response() {
    *this = ::std::move(from);
  }

  inline LogParam_Response& operator=(LogParam_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogParam_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogParam_Response* internal_default_instance() {
    return reinterpret_cast<const LogParam_Response*>(
               &_LogParam_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(LogParam_Response* other);
  friend void swap(LogParam_Response& a, LogParam_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogParam_Response* New() const final {
    return CreateMaybeMessage<LogParam_Response>(NULL);
  }

  LogParam_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogParam_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogParam_Response& from);
  void MergeFrom(const LogParam_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogParam_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.LogParam.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.LogParam) */ {
 public:
  LogParam();
  virtual ~LogParam();

  LogParam(const LogParam& from);

  inline LogParam& operator=(const LogParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogParam(LogParam&& from) noexcept
    : LogParam() {
    *this = ::std::move(from);
  }

  inline LogParam& operator=(LogParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogParam* internal_default_instance() {
    return reinterpret_cast<const LogParam*>(
               &_LogParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(LogParam* other);
  friend void swap(LogParam& a, LogParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogParam* New() const final {
    return CreateMaybeMessage<LogParam>(NULL);
  }

  LogParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogParam& from);
  void MergeFrom(const LogParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef LogParam_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string key = 2 [(.validate_required) = true];
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 3 [(.validate_required) = true];
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mlflow.LogParam)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetTag_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.SetTag.Response) */ {
 public:
  SetTag_Response();
  virtual ~SetTag_Response();

  SetTag_Response(const SetTag_Response& from);

  inline SetTag_Response& operator=(const SetTag_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetTag_Response(SetTag_Response&& from) noexcept
    : SetTag_Response() {
    *this = ::std::move(from);
  }

  inline SetTag_Response& operator=(SetTag_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTag_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetTag_Response* internal_default_instance() {
    return reinterpret_cast<const SetTag_Response*>(
               &_SetTag_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(SetTag_Response* other);
  friend void swap(SetTag_Response& a, SetTag_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetTag_Response* New() const final {
    return CreateMaybeMessage<SetTag_Response>(NULL);
  }

  SetTag_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetTag_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetTag_Response& from);
  void MergeFrom(const SetTag_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTag_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.SetTag.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetTag : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.SetTag) */ {
 public:
  SetTag();
  virtual ~SetTag();

  SetTag(const SetTag& from);

  inline SetTag& operator=(const SetTag& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetTag(SetTag&& from) noexcept
    : SetTag() {
    *this = ::std::move(from);
  }

  inline SetTag& operator=(SetTag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SetTag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetTag* internal_default_instance() {
    return reinterpret_cast<const SetTag*>(
               &_SetTag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(SetTag* other);
  friend void swap(SetTag& a, SetTag& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetTag* New() const final {
    return CreateMaybeMessage<SetTag>(NULL);
  }

  SetTag* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetTag>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetTag& from);
  void MergeFrom(const SetTag& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetTag* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SetTag_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string key = 2 [(.validate_required) = true];
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string value = 3 [(.validate_required) = true];
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mlflow.SetTag)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_key();
  void clear_has_key();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRun_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetRun.Response) */ {
 public:
  GetRun_Response();
  virtual ~GetRun_Response();

  GetRun_Response(const GetRun_Response& from);

  inline GetRun_Response& operator=(const GetRun_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRun_Response(GetRun_Response&& from) noexcept
    : GetRun_Response() {
    *this = ::std::move(from);
  }

  inline GetRun_Response& operator=(GetRun_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRun_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRun_Response* internal_default_instance() {
    return reinterpret_cast<const GetRun_Response*>(
               &_GetRun_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(GetRun_Response* other);
  friend void swap(GetRun_Response& a, GetRun_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRun_Response* New() const final {
    return CreateMaybeMessage<GetRun_Response>(NULL);
  }

  GetRun_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRun_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRun_Response& from);
  void MergeFrom(const GetRun_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRun_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.Run run = 1;
  bool has_run() const;
  void clear_run();
  static const int kRunFieldNumber = 1;
  private:
  const ::mlflow::Run& _internal_run() const;
  public:
  const ::mlflow::Run& run() const;
  ::mlflow::Run* release_run();
  ::mlflow::Run* mutable_run();
  void set_allocated_run(::mlflow::Run* run);

  // @@protoc_insertion_point(class_scope:mlflow.GetRun.Response)
 private:
  void set_has_run();
  void clear_has_run();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mlflow::Run* run_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetRun : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetRun) */ {
 public:
  GetRun();
  virtual ~GetRun();

  GetRun(const GetRun& from);

  inline GetRun& operator=(const GetRun& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetRun(GetRun&& from) noexcept
    : GetRun() {
    *this = ::std::move(from);
  }

  inline GetRun& operator=(GetRun&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetRun& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetRun* internal_default_instance() {
    return reinterpret_cast<const GetRun*>(
               &_GetRun_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(GetRun* other);
  friend void swap(GetRun& a, GetRun& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetRun* New() const final {
    return CreateMaybeMessage<GetRun>(NULL);
  }

  GetRun* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetRun>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetRun& from);
  void MergeFrom(const GetRun& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetRun* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetRun_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // @@protoc_insertion_point(class_scope:mlflow.GetRun)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMetric_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetMetric.Response) */ {
 public:
  GetMetric_Response();
  virtual ~GetMetric_Response();

  GetMetric_Response(const GetMetric_Response& from);

  inline GetMetric_Response& operator=(const GetMetric_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMetric_Response(GetMetric_Response&& from) noexcept
    : GetMetric_Response() {
    *this = ::std::move(from);
  }

  inline GetMetric_Response& operator=(GetMetric_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMetric_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMetric_Response* internal_default_instance() {
    return reinterpret_cast<const GetMetric_Response*>(
               &_GetMetric_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(GetMetric_Response* other);
  friend void swap(GetMetric_Response& a, GetMetric_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMetric_Response* New() const final {
    return CreateMaybeMessage<GetMetric_Response>(NULL);
  }

  GetMetric_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMetric_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMetric_Response& from);
  void MergeFrom(const GetMetric_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetric_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.Metric metric = 1;
  bool has_metric() const;
  void clear_metric();
  static const int kMetricFieldNumber = 1;
  private:
  const ::mlflow::Metric& _internal_metric() const;
  public:
  const ::mlflow::Metric& metric() const;
  ::mlflow::Metric* release_metric();
  ::mlflow::Metric* mutable_metric();
  void set_allocated_metric(::mlflow::Metric* metric);

  // @@protoc_insertion_point(class_scope:mlflow.GetMetric.Response)
 private:
  void set_has_metric();
  void clear_has_metric();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mlflow::Metric* metric_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMetric : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetMetric) */ {
 public:
  GetMetric();
  virtual ~GetMetric();

  GetMetric(const GetMetric& from);

  inline GetMetric& operator=(const GetMetric& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMetric(GetMetric&& from) noexcept
    : GetMetric() {
    *this = ::std::move(from);
  }

  inline GetMetric& operator=(GetMetric&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMetric& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMetric* internal_default_instance() {
    return reinterpret_cast<const GetMetric*>(
               &_GetMetric_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  void Swap(GetMetric* other);
  friend void swap(GetMetric& a, GetMetric& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMetric* New() const final {
    return CreateMaybeMessage<GetMetric>(NULL);
  }

  GetMetric* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMetric>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMetric& from);
  void MergeFrom(const GetMetric& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetric* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetMetric_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string metric_key = 2 [(.validate_required) = true];
  bool has_metric_key() const;
  void clear_metric_key();
  static const int kMetricKeyFieldNumber = 2;
  const ::std::string& metric_key() const;
  void set_metric_key(const ::std::string& value);
  #if LANG_CXX11
  void set_metric_key(::std::string&& value);
  #endif
  void set_metric_key(const char* value);
  void set_metric_key(const char* value, size_t size);
  ::std::string* mutable_metric_key();
  ::std::string* release_metric_key();
  void set_allocated_metric_key(::std::string* metric_key);

  // @@protoc_insertion_point(class_scope:mlflow.GetMetric)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_metric_key();
  void clear_has_metric_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr metric_key_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetParam_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetParam.Response) */ {
 public:
  GetParam_Response();
  virtual ~GetParam_Response();

  GetParam_Response(const GetParam_Response& from);

  inline GetParam_Response& operator=(const GetParam_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetParam_Response(GetParam_Response&& from) noexcept
    : GetParam_Response() {
    *this = ::std::move(from);
  }

  inline GetParam_Response& operator=(GetParam_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetParam_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetParam_Response* internal_default_instance() {
    return reinterpret_cast<const GetParam_Response*>(
               &_GetParam_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  void Swap(GetParam_Response* other);
  friend void swap(GetParam_Response& a, GetParam_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetParam_Response* New() const final {
    return CreateMaybeMessage<GetParam_Response>(NULL);
  }

  GetParam_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetParam_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetParam_Response& from);
  void MergeFrom(const GetParam_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetParam_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.Param parameter = 1;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 1;
  private:
  const ::mlflow::Param& _internal_parameter() const;
  public:
  const ::mlflow::Param& parameter() const;
  ::mlflow::Param* release_parameter();
  ::mlflow::Param* mutable_parameter();
  void set_allocated_parameter(::mlflow::Param* parameter);

  // @@protoc_insertion_point(class_scope:mlflow.GetParam.Response)
 private:
  void set_has_parameter();
  void clear_has_parameter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::mlflow::Param* parameter_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetParam : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetParam) */ {
 public:
  GetParam();
  virtual ~GetParam();

  GetParam(const GetParam& from);

  inline GetParam& operator=(const GetParam& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetParam(GetParam&& from) noexcept
    : GetParam() {
    *this = ::std::move(from);
  }

  inline GetParam& operator=(GetParam&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetParam& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetParam* internal_default_instance() {
    return reinterpret_cast<const GetParam*>(
               &_GetParam_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  void Swap(GetParam* other);
  friend void swap(GetParam& a, GetParam& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetParam* New() const final {
    return CreateMaybeMessage<GetParam>(NULL);
  }

  GetParam* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetParam>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetParam& from);
  void MergeFrom(const GetParam& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetParam* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetParam_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string param_name = 2 [(.validate_required) = true];
  bool has_param_name() const;
  void clear_param_name();
  static const int kParamNameFieldNumber = 2;
  const ::std::string& param_name() const;
  void set_param_name(const ::std::string& value);
  #if LANG_CXX11
  void set_param_name(::std::string&& value);
  #endif
  void set_param_name(const char* value);
  void set_param_name(const char* value, size_t size);
  ::std::string* mutable_param_name();
  ::std::string* release_param_name();
  void set_allocated_param_name(::std::string* param_name);

  // @@protoc_insertion_point(class_scope:mlflow.GetParam)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_param_name();
  void clear_has_param_name();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr param_name_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SearchExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.SearchExpression) */ {
 public:
  SearchExpression();
  virtual ~SearchExpression();

  SearchExpression(const SearchExpression& from);

  inline SearchExpression& operator=(const SearchExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchExpression(SearchExpression&& from) noexcept
    : SearchExpression() {
    *this = ::std::move(from);
  }

  inline SearchExpression& operator=(SearchExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchExpression& default_instance();

  enum ExpressionCase {
    kMetric = 1,
    kParameter = 2,
    EXPRESSION_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchExpression* internal_default_instance() {
    return reinterpret_cast<const SearchExpression*>(
               &_SearchExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  void Swap(SearchExpression* other);
  friend void swap(SearchExpression& a, SearchExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchExpression* New() const final {
    return CreateMaybeMessage<SearchExpression>(NULL);
  }

  SearchExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchExpression& from);
  void MergeFrom(const SearchExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .mlflow.MetricSearchExpression metric = 1;
  bool has_metric() const;
  void clear_metric();
  static const int kMetricFieldNumber = 1;
  private:
  const ::mlflow::MetricSearchExpression& _internal_metric() const;
  public:
  const ::mlflow::MetricSearchExpression& metric() const;
  ::mlflow::MetricSearchExpression* release_metric();
  ::mlflow::MetricSearchExpression* mutable_metric();
  void set_allocated_metric(::mlflow::MetricSearchExpression* metric);

  // optional .mlflow.ParameterSearchExpression parameter = 2;
  bool has_parameter() const;
  void clear_parameter();
  static const int kParameterFieldNumber = 2;
  private:
  const ::mlflow::ParameterSearchExpression& _internal_parameter() const;
  public:
  const ::mlflow::ParameterSearchExpression& parameter() const;
  ::mlflow::ParameterSearchExpression* release_parameter();
  ::mlflow::ParameterSearchExpression* mutable_parameter();
  void set_allocated_parameter(::mlflow::ParameterSearchExpression* parameter);

  void clear_expression();
  ExpressionCase expression_case() const;
  // @@protoc_insertion_point(class_scope:mlflow.SearchExpression)
 private:
  void set_has_metric();
  void set_has_parameter();

  inline bool has_expression() const;
  inline void clear_has_expression();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  union ExpressionUnion {
    ExpressionUnion() {}
    ::mlflow::MetricSearchExpression* metric_;
    ::mlflow::ParameterSearchExpression* parameter_;
  } expression_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MetricSearchExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.MetricSearchExpression) */ {
 public:
  MetricSearchExpression();
  virtual ~MetricSearchExpression();

  MetricSearchExpression(const MetricSearchExpression& from);

  inline MetricSearchExpression& operator=(const MetricSearchExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MetricSearchExpression(MetricSearchExpression&& from) noexcept
    : MetricSearchExpression() {
    *this = ::std::move(from);
  }

  inline MetricSearchExpression& operator=(MetricSearchExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MetricSearchExpression& default_instance();

  enum ClauseCase {
    kFloat = 2,
    kDouble = 3,
    CLAUSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MetricSearchExpression* internal_default_instance() {
    return reinterpret_cast<const MetricSearchExpression*>(
               &_MetricSearchExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  void Swap(MetricSearchExpression* other);
  friend void swap(MetricSearchExpression& a, MetricSearchExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MetricSearchExpression* New() const final {
    return CreateMaybeMessage<MetricSearchExpression>(NULL);
  }

  MetricSearchExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MetricSearchExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MetricSearchExpression& from);
  void MergeFrom(const MetricSearchExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MetricSearchExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .mlflow.FloatClause float = 2;
  bool has_float_() const;
  void clear_float_();
  static const int kFloatFieldNumber = 2;
  private:
  const ::mlflow::FloatClause& _internal_float_() const;
  public:
  const ::mlflow::FloatClause& float_() const;
  ::mlflow::FloatClause* release_float_();
  ::mlflow::FloatClause* mutable_float_();
  void set_allocated_float_(::mlflow::FloatClause* float_);

  // optional .mlflow.DoubleClause double = 3;
  bool has_double_() const;
  void clear_double_();
  static const int kDoubleFieldNumber = 3;
  private:
  const ::mlflow::DoubleClause& _internal_double_() const;
  public:
  const ::mlflow::DoubleClause& double_() const;
  ::mlflow::DoubleClause* release_double_();
  ::mlflow::DoubleClause* mutable_double_();
  void set_allocated_double_(::mlflow::DoubleClause* double_);

  void clear_clause();
  ClauseCase clause_case() const;
  // @@protoc_insertion_point(class_scope:mlflow.MetricSearchExpression)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_float_();
  void set_has_double_();

  inline bool has_clause() const;
  inline void clear_has_clause();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  union ClauseUnion {
    ClauseUnion() {}
    ::mlflow::FloatClause* float__;
    ::mlflow::DoubleClause* double__;
  } clause_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ParameterSearchExpression : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.ParameterSearchExpression) */ {
 public:
  ParameterSearchExpression();
  virtual ~ParameterSearchExpression();

  ParameterSearchExpression(const ParameterSearchExpression& from);

  inline ParameterSearchExpression& operator=(const ParameterSearchExpression& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ParameterSearchExpression(ParameterSearchExpression&& from) noexcept
    : ParameterSearchExpression() {
    *this = ::std::move(from);
  }

  inline ParameterSearchExpression& operator=(ParameterSearchExpression&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParameterSearchExpression& default_instance();

  enum ClauseCase {
    kString = 2,
    CLAUSE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ParameterSearchExpression* internal_default_instance() {
    return reinterpret_cast<const ParameterSearchExpression*>(
               &_ParameterSearchExpression_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  void Swap(ParameterSearchExpression* other);
  friend void swap(ParameterSearchExpression& a, ParameterSearchExpression& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ParameterSearchExpression* New() const final {
    return CreateMaybeMessage<ParameterSearchExpression>(NULL);
  }

  ParameterSearchExpression* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ParameterSearchExpression>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ParameterSearchExpression& from);
  void MergeFrom(const ParameterSearchExpression& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ParameterSearchExpression* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional .mlflow.StringClause string = 2;
  bool has_string() const;
  void clear_string();
  static const int kStringFieldNumber = 2;
  private:
  const ::mlflow::StringClause& _internal_string() const;
  public:
  const ::mlflow::StringClause& string() const;
  ::mlflow::StringClause* release_string();
  ::mlflow::StringClause* mutable_string();
  void set_allocated_string(::mlflow::StringClause* string);

  void clear_clause();
  ClauseCase clause_case() const;
  // @@protoc_insertion_point(class_scope:mlflow.ParameterSearchExpression)
 private:
  void set_has_key();
  void clear_has_key();
  void set_has_string();

  inline bool has_clause() const;
  inline void clear_has_clause();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  union ClauseUnion {
    ClauseUnion() {}
    ::mlflow::StringClause* string_;
  } clause_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StringClause : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.StringClause) */ {
 public:
  StringClause();
  virtual ~StringClause();

  StringClause(const StringClause& from);

  inline StringClause& operator=(const StringClause& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringClause(StringClause&& from) noexcept
    : StringClause() {
    *this = ::std::move(from);
  }

  inline StringClause& operator=(StringClause&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StringClause& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringClause* internal_default_instance() {
    return reinterpret_cast<const StringClause*>(
               &_StringClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  void Swap(StringClause* other);
  friend void swap(StringClause& a, StringClause& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringClause* New() const final {
    return CreateMaybeMessage<StringClause>(NULL);
  }

  StringClause* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringClause>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringClause& from);
  void MergeFrom(const StringClause& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringClause* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string comparator = 1;
  bool has_comparator() const;
  void clear_comparator();
  static const int kComparatorFieldNumber = 1;
  const ::std::string& comparator() const;
  void set_comparator(const ::std::string& value);
  #if LANG_CXX11
  void set_comparator(::std::string&& value);
  #endif
  void set_comparator(const char* value);
  void set_comparator(const char* value, size_t size);
  ::std::string* mutable_comparator();
  ::std::string* release_comparator();
  void set_allocated_comparator(::std::string* comparator);

  // optional string value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mlflow.StringClause)
 private:
  void set_has_comparator();
  void clear_has_comparator();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr comparator_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FloatClause : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.FloatClause) */ {
 public:
  FloatClause();
  virtual ~FloatClause();

  FloatClause(const FloatClause& from);

  inline FloatClause& operator=(const FloatClause& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatClause(FloatClause&& from) noexcept
    : FloatClause() {
    *this = ::std::move(from);
  }

  inline FloatClause& operator=(FloatClause&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FloatClause& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatClause* internal_default_instance() {
    return reinterpret_cast<const FloatClause*>(
               &_FloatClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  void Swap(FloatClause* other);
  friend void swap(FloatClause& a, FloatClause& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatClause* New() const final {
    return CreateMaybeMessage<FloatClause>(NULL);
  }

  FloatClause* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatClause>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatClause& from);
  void MergeFrom(const FloatClause& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatClause* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string comparator = 1;
  bool has_comparator() const;
  void clear_comparator();
  static const int kComparatorFieldNumber = 1;
  const ::std::string& comparator() const;
  void set_comparator(const ::std::string& value);
  #if LANG_CXX11
  void set_comparator(::std::string&& value);
  #endif
  void set_comparator(const char* value);
  void set_comparator(const char* value, size_t size);
  ::std::string* mutable_comparator();
  ::std::string* release_comparator();
  void set_allocated_comparator(::std::string* comparator);

  // optional float value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:mlflow.FloatClause)
 private:
  void set_has_comparator();
  void clear_has_comparator();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr comparator_;
  float value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleClause : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.DoubleClause) */ {
 public:
  DoubleClause();
  virtual ~DoubleClause();

  DoubleClause(const DoubleClause& from);

  inline DoubleClause& operator=(const DoubleClause& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleClause(DoubleClause&& from) noexcept
    : DoubleClause() {
    *this = ::std::move(from);
  }

  inline DoubleClause& operator=(DoubleClause&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleClause& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleClause* internal_default_instance() {
    return reinterpret_cast<const DoubleClause*>(
               &_DoubleClause_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  void Swap(DoubleClause* other);
  friend void swap(DoubleClause& a, DoubleClause& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleClause* New() const final {
    return CreateMaybeMessage<DoubleClause>(NULL);
  }

  DoubleClause* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleClause>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleClause& from);
  void MergeFrom(const DoubleClause& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleClause* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string comparator = 1;
  bool has_comparator() const;
  void clear_comparator();
  static const int kComparatorFieldNumber = 1;
  const ::std::string& comparator() const;
  void set_comparator(const ::std::string& value);
  #if LANG_CXX11
  void set_comparator(::std::string&& value);
  #endif
  void set_comparator(const char* value);
  void set_comparator(const char* value, size_t size);
  ::std::string* mutable_comparator();
  ::std::string* release_comparator();
  void set_allocated_comparator(::std::string* comparator);

  // optional double value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:mlflow.DoubleClause)
 private:
  void set_has_comparator();
  void clear_has_comparator();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr comparator_;
  double value_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SearchRuns_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.SearchRuns.Response) */ {
 public:
  SearchRuns_Response();
  virtual ~SearchRuns_Response();

  SearchRuns_Response(const SearchRuns_Response& from);

  inline SearchRuns_Response& operator=(const SearchRuns_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchRuns_Response(SearchRuns_Response&& from) noexcept
    : SearchRuns_Response() {
    *this = ::std::move(from);
  }

  inline SearchRuns_Response& operator=(SearchRuns_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRuns_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchRuns_Response* internal_default_instance() {
    return reinterpret_cast<const SearchRuns_Response*>(
               &_SearchRuns_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  void Swap(SearchRuns_Response* other);
  friend void swap(SearchRuns_Response& a, SearchRuns_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchRuns_Response* New() const final {
    return CreateMaybeMessage<SearchRuns_Response>(NULL);
  }

  SearchRuns_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchRuns_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchRuns_Response& from);
  void MergeFrom(const SearchRuns_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRuns_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mlflow.Run runs = 1;
  int runs_size() const;
  void clear_runs();
  static const int kRunsFieldNumber = 1;
  ::mlflow::Run* mutable_runs(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::Run >*
      mutable_runs();
  const ::mlflow::Run& runs(int index) const;
  ::mlflow::Run* add_runs();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::Run >&
      runs() const;

  // @@protoc_insertion_point(class_scope:mlflow.SearchRuns.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::Run > runs_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SearchRuns : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.SearchRuns) */ {
 public:
  SearchRuns();
  virtual ~SearchRuns();

  SearchRuns(const SearchRuns& from);

  inline SearchRuns& operator=(const SearchRuns& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SearchRuns(SearchRuns&& from) noexcept
    : SearchRuns() {
    *this = ::std::move(from);
  }

  inline SearchRuns& operator=(SearchRuns&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchRuns& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SearchRuns* internal_default_instance() {
    return reinterpret_cast<const SearchRuns*>(
               &_SearchRuns_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  void Swap(SearchRuns* other);
  friend void swap(SearchRuns& a, SearchRuns& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SearchRuns* New() const final {
    return CreateMaybeMessage<SearchRuns>(NULL);
  }

  SearchRuns* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SearchRuns>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SearchRuns& from);
  void MergeFrom(const SearchRuns& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SearchRuns* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SearchRuns_Response Response;

  // accessors -------------------------------------------------------

  // repeated int64 experiment_ids = 1;
  int experiment_ids_size() const;
  void clear_experiment_ids();
  static const int kExperimentIdsFieldNumber = 1;
  ::google::protobuf::int64 experiment_ids(int index) const;
  void set_experiment_ids(int index, ::google::protobuf::int64 value);
  void add_experiment_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      experiment_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_experiment_ids();

  // repeated .mlflow.SearchExpression anded_expressions = 2;
  int anded_expressions_size() const;
  void clear_anded_expressions();
  static const int kAndedExpressionsFieldNumber = 2;
  ::mlflow::SearchExpression* mutable_anded_expressions(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::SearchExpression >*
      mutable_anded_expressions();
  const ::mlflow::SearchExpression& anded_expressions(int index) const;
  ::mlflow::SearchExpression* add_anded_expressions();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::SearchExpression >&
      anded_expressions() const;

  // optional .mlflow.ViewType run_view_type = 3 [default = ACTIVE_ONLY];
  bool has_run_view_type() const;
  void clear_run_view_type();
  static const int kRunViewTypeFieldNumber = 3;
  ::mlflow::ViewType run_view_type() const;
  void set_run_view_type(::mlflow::ViewType value);

  // @@protoc_insertion_point(class_scope:mlflow.SearchRuns)
 private:
  void set_has_run_view_type();
  void clear_has_run_view_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > experiment_ids_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::SearchExpression > anded_expressions_;
  int run_view_type_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListArtifacts_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.ListArtifacts.Response) */ {
 public:
  ListArtifacts_Response();
  virtual ~ListArtifacts_Response();

  ListArtifacts_Response(const ListArtifacts_Response& from);

  inline ListArtifacts_Response& operator=(const ListArtifacts_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifacts_Response(ListArtifacts_Response&& from) noexcept
    : ListArtifacts_Response() {
    *this = ::std::move(from);
  }

  inline ListArtifacts_Response& operator=(ListArtifacts_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListArtifacts_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifacts_Response* internal_default_instance() {
    return reinterpret_cast<const ListArtifacts_Response*>(
               &_ListArtifacts_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  void Swap(ListArtifacts_Response* other);
  friend void swap(ListArtifacts_Response& a, ListArtifacts_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifacts_Response* New() const final {
    return CreateMaybeMessage<ListArtifacts_Response>(NULL);
  }

  ListArtifacts_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifacts_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifacts_Response& from);
  void MergeFrom(const ListArtifacts_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifacts_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mlflow.FileInfo files = 2;
  int files_size() const;
  void clear_files();
  static const int kFilesFieldNumber = 2;
  ::mlflow::FileInfo* mutable_files(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::FileInfo >*
      mutable_files();
  const ::mlflow::FileInfo& files(int index) const;
  ::mlflow::FileInfo* add_files();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::FileInfo >&
      files() const;

  // optional string root_uri = 1;
  bool has_root_uri() const;
  void clear_root_uri();
  static const int kRootUriFieldNumber = 1;
  const ::std::string& root_uri() const;
  void set_root_uri(const ::std::string& value);
  #if LANG_CXX11
  void set_root_uri(::std::string&& value);
  #endif
  void set_root_uri(const char* value);
  void set_root_uri(const char* value, size_t size);
  ::std::string* mutable_root_uri();
  ::std::string* release_root_uri();
  void set_allocated_root_uri(::std::string* root_uri);

  // @@protoc_insertion_point(class_scope:mlflow.ListArtifacts.Response)
 private:
  void set_has_root_uri();
  void clear_has_root_uri();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::FileInfo > files_;
  ::google::protobuf::internal::ArenaStringPtr root_uri_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ListArtifacts : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.ListArtifacts) */ {
 public:
  ListArtifacts();
  virtual ~ListArtifacts();

  ListArtifacts(const ListArtifacts& from);

  inline ListArtifacts& operator=(const ListArtifacts& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListArtifacts(ListArtifacts&& from) noexcept
    : ListArtifacts() {
    *this = ::std::move(from);
  }

  inline ListArtifacts& operator=(ListArtifacts&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ListArtifacts& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListArtifacts* internal_default_instance() {
    return reinterpret_cast<const ListArtifacts*>(
               &_ListArtifacts_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  void Swap(ListArtifacts* other);
  friend void swap(ListArtifacts& a, ListArtifacts& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListArtifacts* New() const final {
    return CreateMaybeMessage<ListArtifacts>(NULL);
  }

  ListArtifacts* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ListArtifacts>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ListArtifacts& from);
  void MergeFrom(const ListArtifacts& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListArtifacts* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ListArtifacts_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1;
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mlflow.ListArtifacts)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FileInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.FileInfo) */ {
 public:
  FileInfo();
  virtual ~FileInfo();

  FileInfo(const FileInfo& from);

  inline FileInfo& operator=(const FileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FileInfo(FileInfo&& from) noexcept
    : FileInfo() {
    *this = ::std::move(from);
  }

  inline FileInfo& operator=(FileInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FileInfo* internal_default_instance() {
    return reinterpret_cast<const FileInfo*>(
               &_FileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  void Swap(FileInfo* other);
  friend void swap(FileInfo& a, FileInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FileInfo* New() const final {
    return CreateMaybeMessage<FileInfo>(NULL);
  }

  FileInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FileInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FileInfo& from);
  void MergeFrom(const FileInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 1;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // optional int64 file_size = 3;
  bool has_file_size() const;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  ::google::protobuf::int64 file_size() const;
  void set_file_size(::google::protobuf::int64 value);

  // optional bool is_dir = 2;
  bool has_is_dir() const;
  void clear_is_dir();
  static const int kIsDirFieldNumber = 2;
  bool is_dir() const;
  void set_is_dir(bool value);

  // @@protoc_insertion_point(class_scope:mlflow.FileInfo)
 private:
  void set_has_path();
  void clear_has_path();
  void set_has_is_dir();
  void clear_has_is_dir();
  void set_has_file_size();
  void clear_has_file_size();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  ::google::protobuf::int64 file_size_;
  bool is_dir_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetArtifact_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetArtifact.Response) */ {
 public:
  GetArtifact_Response();
  virtual ~GetArtifact_Response();

  GetArtifact_Response(const GetArtifact_Response& from);

  inline GetArtifact_Response& operator=(const GetArtifact_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifact_Response(GetArtifact_Response&& from) noexcept
    : GetArtifact_Response() {
    *this = ::std::move(from);
  }

  inline GetArtifact_Response& operator=(GetArtifact_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetArtifact_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifact_Response* internal_default_instance() {
    return reinterpret_cast<const GetArtifact_Response*>(
               &_GetArtifact_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  void Swap(GetArtifact_Response* other);
  friend void swap(GetArtifact_Response& a, GetArtifact_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifact_Response* New() const final {
    return CreateMaybeMessage<GetArtifact_Response>(NULL);
  }

  GetArtifact_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifact_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifact_Response& from);
  void MergeFrom(const GetArtifact_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifact_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:mlflow.GetArtifact.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetArtifact : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetArtifact) */ {
 public:
  GetArtifact();
  virtual ~GetArtifact();

  GetArtifact(const GetArtifact& from);

  inline GetArtifact& operator=(const GetArtifact& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetArtifact(GetArtifact&& from) noexcept
    : GetArtifact() {
    *this = ::std::move(from);
  }

  inline GetArtifact& operator=(GetArtifact&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetArtifact& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetArtifact* internal_default_instance() {
    return reinterpret_cast<const GetArtifact*>(
               &_GetArtifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  void Swap(GetArtifact* other);
  friend void swap(GetArtifact& a, GetArtifact& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetArtifact* New() const final {
    return CreateMaybeMessage<GetArtifact>(NULL);
  }

  GetArtifact* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetArtifact>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetArtifact& from);
  void MergeFrom(const GetArtifact& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetArtifact* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetArtifact_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1;
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string path = 2;
  bool has_path() const;
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:mlflow.GetArtifact)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_path();
  void clear_has_path();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr path_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMetricHistory_Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetMetricHistory.Response) */ {
 public:
  GetMetricHistory_Response();
  virtual ~GetMetricHistory_Response();

  GetMetricHistory_Response(const GetMetricHistory_Response& from);

  inline GetMetricHistory_Response& operator=(const GetMetricHistory_Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMetricHistory_Response(GetMetricHistory_Response&& from) noexcept
    : GetMetricHistory_Response() {
    *this = ::std::move(from);
  }

  inline GetMetricHistory_Response& operator=(GetMetricHistory_Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMetricHistory_Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMetricHistory_Response* internal_default_instance() {
    return reinterpret_cast<const GetMetricHistory_Response*>(
               &_GetMetricHistory_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  void Swap(GetMetricHistory_Response* other);
  friend void swap(GetMetricHistory_Response& a, GetMetricHistory_Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMetricHistory_Response* New() const final {
    return CreateMaybeMessage<GetMetricHistory_Response>(NULL);
  }

  GetMetricHistory_Response* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMetricHistory_Response>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMetricHistory_Response& from);
  void MergeFrom(const GetMetricHistory_Response& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetricHistory_Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .mlflow.Metric metrics = 1;
  int metrics_size() const;
  void clear_metrics();
  static const int kMetricsFieldNumber = 1;
  ::mlflow::Metric* mutable_metrics(int index);
  ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >*
      mutable_metrics();
  const ::mlflow::Metric& metrics(int index) const;
  ::mlflow::Metric* add_metrics();
  const ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >&
      metrics() const;

  // @@protoc_insertion_point(class_scope:mlflow.GetMetricHistory.Response)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::mlflow::Metric > metrics_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetMetricHistory : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:mlflow.GetMetricHistory) */ {
 public:
  GetMetricHistory();
  virtual ~GetMetricHistory();

  GetMetricHistory(const GetMetricHistory& from);

  inline GetMetricHistory& operator=(const GetMetricHistory& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetMetricHistory(GetMetricHistory&& from) noexcept
    : GetMetricHistory() {
    *this = ::std::move(from);
  }

  inline GetMetricHistory& operator=(GetMetricHistory&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetMetricHistory& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetMetricHistory* internal_default_instance() {
    return reinterpret_cast<const GetMetricHistory*>(
               &_GetMetricHistory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  void Swap(GetMetricHistory* other);
  friend void swap(GetMetricHistory& a, GetMetricHistory& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetMetricHistory* New() const final {
    return CreateMaybeMessage<GetMetricHistory>(NULL);
  }

  GetMetricHistory* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetMetricHistory>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetMetricHistory& from);
  void MergeFrom(const GetMetricHistory& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetMetricHistory* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetMetricHistory_Response Response;

  // accessors -------------------------------------------------------

  // optional string run_uuid = 1 [(.validate_required) = true];
  bool has_run_uuid() const;
  void clear_run_uuid();
  static const int kRunUuidFieldNumber = 1;
  const ::std::string& run_uuid() const;
  void set_run_uuid(const ::std::string& value);
  #if LANG_CXX11
  void set_run_uuid(::std::string&& value);
  #endif
  void set_run_uuid(const char* value);
  void set_run_uuid(const char* value, size_t size);
  ::std::string* mutable_run_uuid();
  ::std::string* release_run_uuid();
  void set_allocated_run_uuid(::std::string* run_uuid);

  // optional string metric_key = 2 [(.validate_required) = true];
  bool has_metric_key() const;
  void clear_metric_key();
  static const int kMetricKeyFieldNumber = 2;
  const ::std::string& metric_key() const;
  void set_metric_key(const ::std::string& value);
  #if LANG_CXX11
  void set_metric_key(::std::string&& value);
  #endif
  void set_metric_key(const char* value);
  void set_metric_key(const char* value, size_t size);
  ::std::string* mutable_metric_key();
  ::std::string* release_metric_key();
  void set_allocated_metric_key(::std::string* metric_key);

  // @@protoc_insertion_point(class_scope:mlflow.GetMetricHistory)
 private:
  void set_has_run_uuid();
  void clear_has_run_uuid();
  void set_has_metric_key();
  void clear_has_metric_key();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr run_uuid_;
  ::google::protobuf::internal::ArenaStringPtr metric_key_;
  friend struct ::protobuf_service_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Metric

// optional string key = 1;
inline bool Metric::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Metric::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Metric::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Metric::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Metric::key() const {
  // @@protoc_insertion_point(field_get:mlflow.Metric.key)
  return key_.GetNoArena();
}
inline void Metric::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.Metric.key)
}
#if LANG_CXX11
inline void Metric::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.Metric.key)
}
#endif
inline void Metric::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.Metric.key)
}
inline void Metric::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.Metric.key)
}
inline ::std::string* Metric::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.Metric.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Metric::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.Metric.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Metric::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.Metric.key)
}

// optional double value = 2;
inline bool Metric::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Metric::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double Metric::value() const {
  // @@protoc_insertion_point(field_get:mlflow.Metric.value)
  return value_;
}
inline void Metric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mlflow.Metric.value)
}

// optional int64 timestamp = 3;
inline bool Metric::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Metric::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Metric::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Metric::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 Metric::timestamp() const {
  // @@protoc_insertion_point(field_get:mlflow.Metric.timestamp)
  return timestamp_;
}
inline void Metric::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mlflow.Metric.timestamp)
}

// -------------------------------------------------------------------

// Param

// optional string key = 1;
inline bool Param::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Param::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Param::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Param::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& Param::key() const {
  // @@protoc_insertion_point(field_get:mlflow.Param.key)
  return key_.GetNoArena();
}
inline void Param::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.Param.key)
}
#if LANG_CXX11
inline void Param::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.Param.key)
}
#endif
inline void Param::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.Param.key)
}
inline void Param::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.Param.key)
}
inline ::std::string* Param::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.Param.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Param::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.Param.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Param::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.Param.key)
}

// optional string value = 2;
inline bool Param::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Param::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Param::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Param::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& Param::value() const {
  // @@protoc_insertion_point(field_get:mlflow.Param.value)
  return value_.GetNoArena();
}
inline void Param::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.Param.value)
}
#if LANG_CXX11
inline void Param::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.Param.value)
}
#endif
inline void Param::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.Param.value)
}
inline void Param::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.Param.value)
}
inline ::std::string* Param::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mlflow.Param.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Param::release_value() {
  // @@protoc_insertion_point(field_release:mlflow.Param.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Param::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mlflow.Param.value)
}

// -------------------------------------------------------------------

// Run

// optional .mlflow.RunInfo info = 1;
inline bool Run::has_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Run::set_has_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Run::clear_has_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Run::clear_info() {
  if (info_ != NULL) info_->Clear();
  clear_has_info();
}
inline const ::mlflow::RunInfo& Run::_internal_info() const {
  return *info_;
}
inline const ::mlflow::RunInfo& Run::info() const {
  const ::mlflow::RunInfo* p = info_;
  // @@protoc_insertion_point(field_get:mlflow.Run.info)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::RunInfo*>(
      &::mlflow::_RunInfo_default_instance_);
}
inline ::mlflow::RunInfo* Run::release_info() {
  // @@protoc_insertion_point(field_release:mlflow.Run.info)
  clear_has_info();
  ::mlflow::RunInfo* temp = info_;
  info_ = NULL;
  return temp;
}
inline ::mlflow::RunInfo* Run::mutable_info() {
  set_has_info();
  if (info_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::RunInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.Run.info)
  return info_;
}
inline void Run::set_allocated_info(::mlflow::RunInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    set_has_info();
  } else {
    clear_has_info();
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:mlflow.Run.info)
}

// optional .mlflow.RunData data = 2;
inline bool Run::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Run::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Run::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Run::clear_data() {
  if (data_ != NULL) data_->Clear();
  clear_has_data();
}
inline const ::mlflow::RunData& Run::_internal_data() const {
  return *data_;
}
inline const ::mlflow::RunData& Run::data() const {
  const ::mlflow::RunData* p = data_;
  // @@protoc_insertion_point(field_get:mlflow.Run.data)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::RunData*>(
      &::mlflow::_RunData_default_instance_);
}
inline ::mlflow::RunData* Run::release_data() {
  // @@protoc_insertion_point(field_release:mlflow.Run.data)
  clear_has_data();
  ::mlflow::RunData* temp = data_;
  data_ = NULL;
  return temp;
}
inline ::mlflow::RunData* Run::mutable_data() {
  set_has_data();
  if (data_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::RunData>(GetArenaNoVirtual());
    data_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.Run.data)
  return data_;
}
inline void Run::set_allocated_data(::mlflow::RunData* data) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete data_;
  }
  if (data) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      data = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, data, submessage_arena);
    }
    set_has_data();
  } else {
    clear_has_data();
  }
  data_ = data;
  // @@protoc_insertion_point(field_set_allocated:mlflow.Run.data)
}

// -------------------------------------------------------------------

// RunData

// repeated .mlflow.Metric metrics = 1;
inline int RunData::metrics_size() const {
  return metrics_.size();
}
inline void RunData::clear_metrics() {
  metrics_.Clear();
}
inline ::mlflow::Metric* RunData::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.RunData.metrics)
  return metrics_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >*
RunData::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.RunData.metrics)
  return &metrics_;
}
inline const ::mlflow::Metric& RunData::metrics(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.RunData.metrics)
  return metrics_.Get(index);
}
inline ::mlflow::Metric* RunData::add_metrics() {
  // @@protoc_insertion_point(field_add:mlflow.RunData.metrics)
  return metrics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >&
RunData::metrics() const {
  // @@protoc_insertion_point(field_list:mlflow.RunData.metrics)
  return metrics_;
}

// repeated .mlflow.Param params = 2;
inline int RunData::params_size() const {
  return params_.size();
}
inline void RunData::clear_params() {
  params_.Clear();
}
inline ::mlflow::Param* RunData::mutable_params(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.RunData.params)
  return params_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::Param >*
RunData::mutable_params() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.RunData.params)
  return &params_;
}
inline const ::mlflow::Param& RunData::params(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.RunData.params)
  return params_.Get(index);
}
inline ::mlflow::Param* RunData::add_params() {
  // @@protoc_insertion_point(field_add:mlflow.RunData.params)
  return params_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::Param >&
RunData::params() const {
  // @@protoc_insertion_point(field_list:mlflow.RunData.params)
  return params_;
}

// repeated .mlflow.RunTag tags = 3;
inline int RunData::tags_size() const {
  return tags_.size();
}
inline void RunData::clear_tags() {
  tags_.Clear();
}
inline ::mlflow::RunTag* RunData::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.RunData.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >*
RunData::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.RunData.tags)
  return &tags_;
}
inline const ::mlflow::RunTag& RunData::tags(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.RunData.tags)
  return tags_.Get(index);
}
inline ::mlflow::RunTag* RunData::add_tags() {
  // @@protoc_insertion_point(field_add:mlflow.RunData.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >&
RunData::tags() const {
  // @@protoc_insertion_point(field_list:mlflow.RunData.tags)
  return tags_;
}

// -------------------------------------------------------------------

// RunTag

// optional string key = 1;
inline bool RunTag::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunTag::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunTag::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunTag::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& RunTag::key() const {
  // @@protoc_insertion_point(field_get:mlflow.RunTag.key)
  return key_.GetNoArena();
}
inline void RunTag::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunTag.key)
}
#if LANG_CXX11
inline void RunTag::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunTag.key)
}
#endif
inline void RunTag::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunTag.key)
}
inline void RunTag::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunTag.key)
}
inline ::std::string* RunTag::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.RunTag.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunTag::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.RunTag.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunTag::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunTag.key)
}

// optional string value = 2;
inline bool RunTag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunTag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunTag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunTag::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& RunTag::value() const {
  // @@protoc_insertion_point(field_get:mlflow.RunTag.value)
  return value_.GetNoArena();
}
inline void RunTag::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunTag.value)
}
#if LANG_CXX11
inline void RunTag::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunTag.value)
}
#endif
inline void RunTag::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunTag.value)
}
inline void RunTag::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunTag.value)
}
inline ::std::string* RunTag::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mlflow.RunTag.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunTag::release_value() {
  // @@protoc_insertion_point(field_release:mlflow.RunTag.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunTag::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunTag.value)
}

// -------------------------------------------------------------------

// RunInfo

// optional string run_uuid = 1;
inline bool RunInfo::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunInfo::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunInfo::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunInfo::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& RunInfo::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void RunInfo::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.run_uuid)
}
#if LANG_CXX11
inline void RunInfo::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.run_uuid)
}
#endif
inline void RunInfo::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.run_uuid)
}
inline void RunInfo::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.run_uuid)
}
inline ::std::string* RunInfo::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.run_uuid)
}

// optional int64 experiment_id = 2;
inline bool RunInfo::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RunInfo::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RunInfo::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RunInfo::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 RunInfo::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.experiment_id)
  return experiment_id_;
}
inline void RunInfo::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.experiment_id)
}

// optional string name = 3;
inline bool RunInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RunInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RunInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RunInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RunInfo::name() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.name)
  return name_.GetNoArena();
}
inline void RunInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.name)
}
#if LANG_CXX11
inline void RunInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.name)
}
#endif
inline void RunInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.name)
}
inline void RunInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.name)
}
inline ::std::string* RunInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_name() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.name)
}

// optional .mlflow.SourceType source_type = 4;
inline bool RunInfo::has_source_type() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RunInfo::set_has_source_type() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RunInfo::clear_has_source_type() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RunInfo::clear_source_type() {
  source_type_ = 1;
  clear_has_source_type();
}
inline ::mlflow::SourceType RunInfo::source_type() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.source_type)
  return static_cast< ::mlflow::SourceType >(source_type_);
}
inline void RunInfo::set_source_type(::mlflow::SourceType value) {
  assert(::mlflow::SourceType_IsValid(value));
  set_has_source_type();
  source_type_ = value;
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.source_type)
}

// optional string source_name = 5;
inline bool RunInfo::has_source_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RunInfo::set_has_source_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RunInfo::clear_has_source_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RunInfo::clear_source_name() {
  source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_name();
}
inline const ::std::string& RunInfo::source_name() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.source_name)
  return source_name_.GetNoArena();
}
inline void RunInfo::set_source_name(const ::std::string& value) {
  set_has_source_name();
  source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.source_name)
}
#if LANG_CXX11
inline void RunInfo::set_source_name(::std::string&& value) {
  set_has_source_name();
  source_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.source_name)
}
#endif
inline void RunInfo::set_source_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_name();
  source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.source_name)
}
inline void RunInfo::set_source_name(const char* value, size_t size) {
  set_has_source_name();
  source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.source_name)
}
inline ::std::string* RunInfo::mutable_source_name() {
  set_has_source_name();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.source_name)
  return source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_source_name() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.source_name)
  if (!has_source_name()) {
    return NULL;
  }
  clear_has_source_name();
  return source_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_source_name(::std::string* source_name) {
  if (source_name != NULL) {
    set_has_source_name();
  } else {
    clear_has_source_name();
  }
  source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.source_name)
}

// optional string user_id = 6;
inline bool RunInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RunInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RunInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RunInfo::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& RunInfo::user_id() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.user_id)
  return user_id_.GetNoArena();
}
inline void RunInfo::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.user_id)
}
#if LANG_CXX11
inline void RunInfo::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.user_id)
}
#endif
inline void RunInfo::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.user_id)
}
inline void RunInfo::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.user_id)
}
inline ::std::string* RunInfo::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_user_id() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.user_id)
}

// optional .mlflow.RunStatus status = 7;
inline bool RunInfo::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RunInfo::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RunInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RunInfo::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mlflow::RunStatus RunInfo::status() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.status)
  return static_cast< ::mlflow::RunStatus >(status_);
}
inline void RunInfo::set_status(::mlflow::RunStatus value) {
  assert(::mlflow::RunStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.status)
}

// optional int64 start_time = 8;
inline bool RunInfo::has_start_time() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RunInfo::set_has_start_time() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RunInfo::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RunInfo::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 RunInfo::start_time() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.start_time)
  return start_time_;
}
inline void RunInfo::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.start_time)
}

// optional int64 end_time = 9;
inline bool RunInfo::has_end_time() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RunInfo::set_has_end_time() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RunInfo::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RunInfo::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 RunInfo::end_time() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.end_time)
  return end_time_;
}
inline void RunInfo::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.end_time)
}

// optional string source_version = 10;
inline bool RunInfo::has_source_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RunInfo::set_has_source_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RunInfo::clear_has_source_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RunInfo::clear_source_version() {
  source_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_version();
}
inline const ::std::string& RunInfo::source_version() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.source_version)
  return source_version_.GetNoArena();
}
inline void RunInfo::set_source_version(const ::std::string& value) {
  set_has_source_version();
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.source_version)
}
#if LANG_CXX11
inline void RunInfo::set_source_version(::std::string&& value) {
  set_has_source_version();
  source_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.source_version)
}
#endif
inline void RunInfo::set_source_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_version();
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.source_version)
}
inline void RunInfo::set_source_version(const char* value, size_t size) {
  set_has_source_version();
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.source_version)
}
inline ::std::string* RunInfo::mutable_source_version() {
  set_has_source_version();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.source_version)
  return source_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_source_version() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.source_version)
  if (!has_source_version()) {
    return NULL;
  }
  clear_has_source_version();
  return source_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_source_version(::std::string* source_version) {
  if (source_version != NULL) {
    set_has_source_version();
  } else {
    clear_has_source_version();
  }
  source_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_version);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.source_version)
}

// optional string entry_point_name = 11;
inline bool RunInfo::has_entry_point_name() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RunInfo::set_has_entry_point_name() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RunInfo::clear_has_entry_point_name() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RunInfo::clear_entry_point_name() {
  entry_point_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entry_point_name();
}
inline const ::std::string& RunInfo::entry_point_name() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.entry_point_name)
  return entry_point_name_.GetNoArena();
}
inline void RunInfo::set_entry_point_name(const ::std::string& value) {
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.entry_point_name)
}
#if LANG_CXX11
inline void RunInfo::set_entry_point_name(::std::string&& value) {
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.entry_point_name)
}
#endif
inline void RunInfo::set_entry_point_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.entry_point_name)
}
inline void RunInfo::set_entry_point_name(const char* value, size_t size) {
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.entry_point_name)
}
inline ::std::string* RunInfo::mutable_entry_point_name() {
  set_has_entry_point_name();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.entry_point_name)
  return entry_point_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_entry_point_name() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.entry_point_name)
  if (!has_entry_point_name()) {
    return NULL;
  }
  clear_has_entry_point_name();
  return entry_point_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_entry_point_name(::std::string* entry_point_name) {
  if (entry_point_name != NULL) {
    set_has_entry_point_name();
  } else {
    clear_has_entry_point_name();
  }
  entry_point_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entry_point_name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.entry_point_name)
}

// optional string artifact_uri = 13;
inline bool RunInfo::has_artifact_uri() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RunInfo::set_has_artifact_uri() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RunInfo::clear_has_artifact_uri() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RunInfo::clear_artifact_uri() {
  artifact_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_artifact_uri();
}
inline const ::std::string& RunInfo::artifact_uri() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.artifact_uri)
  return artifact_uri_.GetNoArena();
}
inline void RunInfo::set_artifact_uri(const ::std::string& value) {
  set_has_artifact_uri();
  artifact_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.artifact_uri)
}
#if LANG_CXX11
inline void RunInfo::set_artifact_uri(::std::string&& value) {
  set_has_artifact_uri();
  artifact_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.artifact_uri)
}
#endif
inline void RunInfo::set_artifact_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_artifact_uri();
  artifact_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.artifact_uri)
}
inline void RunInfo::set_artifact_uri(const char* value, size_t size) {
  set_has_artifact_uri();
  artifact_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.artifact_uri)
}
inline ::std::string* RunInfo::mutable_artifact_uri() {
  set_has_artifact_uri();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.artifact_uri)
  return artifact_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_artifact_uri() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.artifact_uri)
  if (!has_artifact_uri()) {
    return NULL;
  }
  clear_has_artifact_uri();
  return artifact_uri_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_artifact_uri(::std::string* artifact_uri) {
  if (artifact_uri != NULL) {
    set_has_artifact_uri();
  } else {
    clear_has_artifact_uri();
  }
  artifact_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), artifact_uri);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.artifact_uri)
}

// optional string lifecycle_stage = 14;
inline bool RunInfo::has_lifecycle_stage() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RunInfo::set_has_lifecycle_stage() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RunInfo::clear_has_lifecycle_stage() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RunInfo::clear_lifecycle_stage() {
  lifecycle_stage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lifecycle_stage();
}
inline const ::std::string& RunInfo::lifecycle_stage() const {
  // @@protoc_insertion_point(field_get:mlflow.RunInfo.lifecycle_stage)
  return lifecycle_stage_.GetNoArena();
}
inline void RunInfo::set_lifecycle_stage(const ::std::string& value) {
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RunInfo.lifecycle_stage)
}
#if LANG_CXX11
inline void RunInfo::set_lifecycle_stage(::std::string&& value) {
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RunInfo.lifecycle_stage)
}
#endif
inline void RunInfo::set_lifecycle_stage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RunInfo.lifecycle_stage)
}
inline void RunInfo::set_lifecycle_stage(const char* value, size_t size) {
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RunInfo.lifecycle_stage)
}
inline ::std::string* RunInfo::mutable_lifecycle_stage() {
  set_has_lifecycle_stage();
  // @@protoc_insertion_point(field_mutable:mlflow.RunInfo.lifecycle_stage)
  return lifecycle_stage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RunInfo::release_lifecycle_stage() {
  // @@protoc_insertion_point(field_release:mlflow.RunInfo.lifecycle_stage)
  if (!has_lifecycle_stage()) {
    return NULL;
  }
  clear_has_lifecycle_stage();
  return lifecycle_stage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RunInfo::set_allocated_lifecycle_stage(::std::string* lifecycle_stage) {
  if (lifecycle_stage != NULL) {
    set_has_lifecycle_stage();
  } else {
    clear_has_lifecycle_stage();
  }
  lifecycle_stage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lifecycle_stage);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RunInfo.lifecycle_stage)
}

// -------------------------------------------------------------------

// Experiment

// optional int64 experiment_id = 1;
inline bool Experiment::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Experiment::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Experiment::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Experiment::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 Experiment::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.Experiment.experiment_id)
  return experiment_id_;
}
inline void Experiment::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.Experiment.experiment_id)
}

// optional string name = 2;
inline bool Experiment::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Experiment::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Experiment::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Experiment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& Experiment::name() const {
  // @@protoc_insertion_point(field_get:mlflow.Experiment.name)
  return name_.GetNoArena();
}
inline void Experiment::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.Experiment.name)
}
#if LANG_CXX11
inline void Experiment::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.Experiment.name)
}
#endif
inline void Experiment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.Experiment.name)
}
inline void Experiment::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.Experiment.name)
}
inline ::std::string* Experiment::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mlflow.Experiment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Experiment::release_name() {
  // @@protoc_insertion_point(field_release:mlflow.Experiment.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Experiment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.Experiment.name)
}

// optional string artifact_location = 3;
inline bool Experiment::has_artifact_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Experiment::set_has_artifact_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Experiment::clear_has_artifact_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Experiment::clear_artifact_location() {
  artifact_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_artifact_location();
}
inline const ::std::string& Experiment::artifact_location() const {
  // @@protoc_insertion_point(field_get:mlflow.Experiment.artifact_location)
  return artifact_location_.GetNoArena();
}
inline void Experiment::set_artifact_location(const ::std::string& value) {
  set_has_artifact_location();
  artifact_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.Experiment.artifact_location)
}
#if LANG_CXX11
inline void Experiment::set_artifact_location(::std::string&& value) {
  set_has_artifact_location();
  artifact_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.Experiment.artifact_location)
}
#endif
inline void Experiment::set_artifact_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_artifact_location();
  artifact_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.Experiment.artifact_location)
}
inline void Experiment::set_artifact_location(const char* value, size_t size) {
  set_has_artifact_location();
  artifact_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.Experiment.artifact_location)
}
inline ::std::string* Experiment::mutable_artifact_location() {
  set_has_artifact_location();
  // @@protoc_insertion_point(field_mutable:mlflow.Experiment.artifact_location)
  return artifact_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Experiment::release_artifact_location() {
  // @@protoc_insertion_point(field_release:mlflow.Experiment.artifact_location)
  if (!has_artifact_location()) {
    return NULL;
  }
  clear_has_artifact_location();
  return artifact_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Experiment::set_allocated_artifact_location(::std::string* artifact_location) {
  if (artifact_location != NULL) {
    set_has_artifact_location();
  } else {
    clear_has_artifact_location();
  }
  artifact_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), artifact_location);
  // @@protoc_insertion_point(field_set_allocated:mlflow.Experiment.artifact_location)
}

// optional string lifecycle_stage = 4;
inline bool Experiment::has_lifecycle_stage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Experiment::set_has_lifecycle_stage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Experiment::clear_has_lifecycle_stage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Experiment::clear_lifecycle_stage() {
  lifecycle_stage_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_lifecycle_stage();
}
inline const ::std::string& Experiment::lifecycle_stage() const {
  // @@protoc_insertion_point(field_get:mlflow.Experiment.lifecycle_stage)
  return lifecycle_stage_.GetNoArena();
}
inline void Experiment::set_lifecycle_stage(const ::std::string& value) {
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.Experiment.lifecycle_stage)
}
#if LANG_CXX11
inline void Experiment::set_lifecycle_stage(::std::string&& value) {
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.Experiment.lifecycle_stage)
}
#endif
inline void Experiment::set_lifecycle_stage(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.Experiment.lifecycle_stage)
}
inline void Experiment::set_lifecycle_stage(const char* value, size_t size) {
  set_has_lifecycle_stage();
  lifecycle_stage_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.Experiment.lifecycle_stage)
}
inline ::std::string* Experiment::mutable_lifecycle_stage() {
  set_has_lifecycle_stage();
  // @@protoc_insertion_point(field_mutable:mlflow.Experiment.lifecycle_stage)
  return lifecycle_stage_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Experiment::release_lifecycle_stage() {
  // @@protoc_insertion_point(field_release:mlflow.Experiment.lifecycle_stage)
  if (!has_lifecycle_stage()) {
    return NULL;
  }
  clear_has_lifecycle_stage();
  return lifecycle_stage_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Experiment::set_allocated_lifecycle_stage(::std::string* lifecycle_stage) {
  if (lifecycle_stage != NULL) {
    set_has_lifecycle_stage();
  } else {
    clear_has_lifecycle_stage();
  }
  lifecycle_stage_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lifecycle_stage);
  // @@protoc_insertion_point(field_set_allocated:mlflow.Experiment.lifecycle_stage)
}

// optional int64 last_update_time = 5;
inline bool Experiment::has_last_update_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Experiment::set_has_last_update_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Experiment::clear_has_last_update_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Experiment::clear_last_update_time() {
  last_update_time_ = GOOGLE_LONGLONG(0);
  clear_has_last_update_time();
}
inline ::google::protobuf::int64 Experiment::last_update_time() const {
  // @@protoc_insertion_point(field_get:mlflow.Experiment.last_update_time)
  return last_update_time_;
}
inline void Experiment::set_last_update_time(::google::protobuf::int64 value) {
  set_has_last_update_time();
  last_update_time_ = value;
  // @@protoc_insertion_point(field_set:mlflow.Experiment.last_update_time)
}

// optional int64 creation_time = 6;
inline bool Experiment::has_creation_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Experiment::set_has_creation_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Experiment::clear_has_creation_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Experiment::clear_creation_time() {
  creation_time_ = GOOGLE_LONGLONG(0);
  clear_has_creation_time();
}
inline ::google::protobuf::int64 Experiment::creation_time() const {
  // @@protoc_insertion_point(field_get:mlflow.Experiment.creation_time)
  return creation_time_;
}
inline void Experiment::set_creation_time(::google::protobuf::int64 value) {
  set_has_creation_time();
  creation_time_ = value;
  // @@protoc_insertion_point(field_set:mlflow.Experiment.creation_time)
}

// -------------------------------------------------------------------

// CreateExperiment_Response

// optional int64 experiment_id = 1;
inline bool CreateExperiment_Response::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateExperiment_Response::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateExperiment_Response::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateExperiment_Response::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 CreateExperiment_Response::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateExperiment.Response.experiment_id)
  return experiment_id_;
}
inline void CreateExperiment_Response::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.CreateExperiment.Response.experiment_id)
}

// -------------------------------------------------------------------

// CreateExperiment

// optional string name = 1 [(.validate_required) = true];
inline bool CreateExperiment::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateExperiment::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateExperiment::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateExperiment::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& CreateExperiment::name() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateExperiment.name)
  return name_.GetNoArena();
}
inline void CreateExperiment::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateExperiment.name)
}
#if LANG_CXX11
inline void CreateExperiment::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateExperiment.name)
}
#endif
inline void CreateExperiment::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateExperiment.name)
}
inline void CreateExperiment::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateExperiment.name)
}
inline ::std::string* CreateExperiment::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateExperiment.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateExperiment::release_name() {
  // @@protoc_insertion_point(field_release:mlflow.CreateExperiment.name)
  if (!has_name()) {
    return NULL;
  }
  clear_has_name();
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateExperiment::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateExperiment.name)
}

// optional string artifact_location = 5;
inline bool CreateExperiment::has_artifact_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateExperiment::set_has_artifact_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateExperiment::clear_has_artifact_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateExperiment::clear_artifact_location() {
  artifact_location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_artifact_location();
}
inline const ::std::string& CreateExperiment::artifact_location() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateExperiment.artifact_location)
  return artifact_location_.GetNoArena();
}
inline void CreateExperiment::set_artifact_location(const ::std::string& value) {
  set_has_artifact_location();
  artifact_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateExperiment.artifact_location)
}
#if LANG_CXX11
inline void CreateExperiment::set_artifact_location(::std::string&& value) {
  set_has_artifact_location();
  artifact_location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateExperiment.artifact_location)
}
#endif
inline void CreateExperiment::set_artifact_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_artifact_location();
  artifact_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateExperiment.artifact_location)
}
inline void CreateExperiment::set_artifact_location(const char* value, size_t size) {
  set_has_artifact_location();
  artifact_location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateExperiment.artifact_location)
}
inline ::std::string* CreateExperiment::mutable_artifact_location() {
  set_has_artifact_location();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateExperiment.artifact_location)
  return artifact_location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateExperiment::release_artifact_location() {
  // @@protoc_insertion_point(field_release:mlflow.CreateExperiment.artifact_location)
  if (!has_artifact_location()) {
    return NULL;
  }
  clear_has_artifact_location();
  return artifact_location_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateExperiment::set_allocated_artifact_location(::std::string* artifact_location) {
  if (artifact_location != NULL) {
    set_has_artifact_location();
  } else {
    clear_has_artifact_location();
  }
  artifact_location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), artifact_location);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateExperiment.artifact_location)
}

// -------------------------------------------------------------------

// ListExperiments_Response

// repeated .mlflow.Experiment experiments = 1;
inline int ListExperiments_Response::experiments_size() const {
  return experiments_.size();
}
inline void ListExperiments_Response::clear_experiments() {
  experiments_.Clear();
}
inline ::mlflow::Experiment* ListExperiments_Response::mutable_experiments(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.ListExperiments.Response.experiments)
  return experiments_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::Experiment >*
ListExperiments_Response::mutable_experiments() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.ListExperiments.Response.experiments)
  return &experiments_;
}
inline const ::mlflow::Experiment& ListExperiments_Response::experiments(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.ListExperiments.Response.experiments)
  return experiments_.Get(index);
}
inline ::mlflow::Experiment* ListExperiments_Response::add_experiments() {
  // @@protoc_insertion_point(field_add:mlflow.ListExperiments.Response.experiments)
  return experiments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::Experiment >&
ListExperiments_Response::experiments() const {
  // @@protoc_insertion_point(field_list:mlflow.ListExperiments.Response.experiments)
  return experiments_;
}

// -------------------------------------------------------------------

// ListExperiments

// optional .mlflow.ViewType view_type = 1;
inline bool ListExperiments::has_view_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListExperiments::set_has_view_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListExperiments::clear_has_view_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListExperiments::clear_view_type() {
  view_type_ = 1;
  clear_has_view_type();
}
inline ::mlflow::ViewType ListExperiments::view_type() const {
  // @@protoc_insertion_point(field_get:mlflow.ListExperiments.view_type)
  return static_cast< ::mlflow::ViewType >(view_type_);
}
inline void ListExperiments::set_view_type(::mlflow::ViewType value) {
  assert(::mlflow::ViewType_IsValid(value));
  set_has_view_type();
  view_type_ = value;
  // @@protoc_insertion_point(field_set:mlflow.ListExperiments.view_type)
}

// -------------------------------------------------------------------

// GetExperiment_Response

// optional .mlflow.Experiment experiment = 1;
inline bool GetExperiment_Response::has_experiment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetExperiment_Response::set_has_experiment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetExperiment_Response::clear_has_experiment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetExperiment_Response::clear_experiment() {
  if (experiment_ != NULL) experiment_->Clear();
  clear_has_experiment();
}
inline const ::mlflow::Experiment& GetExperiment_Response::_internal_experiment() const {
  return *experiment_;
}
inline const ::mlflow::Experiment& GetExperiment_Response::experiment() const {
  const ::mlflow::Experiment* p = experiment_;
  // @@protoc_insertion_point(field_get:mlflow.GetExperiment.Response.experiment)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::Experiment*>(
      &::mlflow::_Experiment_default_instance_);
}
inline ::mlflow::Experiment* GetExperiment_Response::release_experiment() {
  // @@protoc_insertion_point(field_release:mlflow.GetExperiment.Response.experiment)
  clear_has_experiment();
  ::mlflow::Experiment* temp = experiment_;
  experiment_ = NULL;
  return temp;
}
inline ::mlflow::Experiment* GetExperiment_Response::mutable_experiment() {
  set_has_experiment();
  if (experiment_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::Experiment>(GetArenaNoVirtual());
    experiment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.GetExperiment.Response.experiment)
  return experiment_;
}
inline void GetExperiment_Response::set_allocated_experiment(::mlflow::Experiment* experiment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete experiment_;
  }
  if (experiment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      experiment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, experiment, submessage_arena);
    }
    set_has_experiment();
  } else {
    clear_has_experiment();
  }
  experiment_ = experiment;
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetExperiment.Response.experiment)
}

// repeated .mlflow.RunInfo runs = 2;
inline int GetExperiment_Response::runs_size() const {
  return runs_.size();
}
inline void GetExperiment_Response::clear_runs() {
  runs_.Clear();
}
inline ::mlflow::RunInfo* GetExperiment_Response::mutable_runs(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.GetExperiment.Response.runs)
  return runs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::RunInfo >*
GetExperiment_Response::mutable_runs() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.GetExperiment.Response.runs)
  return &runs_;
}
inline const ::mlflow::RunInfo& GetExperiment_Response::runs(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.GetExperiment.Response.runs)
  return runs_.Get(index);
}
inline ::mlflow::RunInfo* GetExperiment_Response::add_runs() {
  // @@protoc_insertion_point(field_add:mlflow.GetExperiment.Response.runs)
  return runs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::RunInfo >&
GetExperiment_Response::runs() const {
  // @@protoc_insertion_point(field_list:mlflow.GetExperiment.Response.runs)
  return runs_;
}

// -------------------------------------------------------------------

// GetExperiment

// optional int64 experiment_id = 1 [(.validate_required) = true];
inline bool GetExperiment::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetExperiment::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetExperiment::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetExperiment::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 GetExperiment::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.GetExperiment.experiment_id)
  return experiment_id_;
}
inline void GetExperiment::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.GetExperiment.experiment_id)
}

// -------------------------------------------------------------------

// DeleteExperiment_Response

// -------------------------------------------------------------------

// DeleteExperiment

// optional int64 experiment_id = 1 [(.validate_required) = true];
inline bool DeleteExperiment::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteExperiment::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteExperiment::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteExperiment::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 DeleteExperiment::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.DeleteExperiment.experiment_id)
  return experiment_id_;
}
inline void DeleteExperiment::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.DeleteExperiment.experiment_id)
}

// -------------------------------------------------------------------

// RestoreExperiment_Response

// -------------------------------------------------------------------

// RestoreExperiment

// optional int64 experiment_id = 1 [(.validate_required) = true];
inline bool RestoreExperiment::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestoreExperiment::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestoreExperiment::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestoreExperiment::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 RestoreExperiment::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.RestoreExperiment.experiment_id)
  return experiment_id_;
}
inline void RestoreExperiment::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.RestoreExperiment.experiment_id)
}

// -------------------------------------------------------------------

// CreateRun_Response

// optional .mlflow.Run run = 1;
inline bool CreateRun_Response::has_run() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRun_Response::set_has_run() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRun_Response::clear_has_run() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRun_Response::clear_run() {
  if (run_ != NULL) run_->Clear();
  clear_has_run();
}
inline const ::mlflow::Run& CreateRun_Response::_internal_run() const {
  return *run_;
}
inline const ::mlflow::Run& CreateRun_Response::run() const {
  const ::mlflow::Run* p = run_;
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.Response.run)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::Run*>(
      &::mlflow::_Run_default_instance_);
}
inline ::mlflow::Run* CreateRun_Response::release_run() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.Response.run)
  clear_has_run();
  ::mlflow::Run* temp = run_;
  run_ = NULL;
  return temp;
}
inline ::mlflow::Run* CreateRun_Response::mutable_run() {
  set_has_run();
  if (run_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::Run>(GetArenaNoVirtual());
    run_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.Response.run)
  return run_;
}
inline void CreateRun_Response::set_allocated_run(::mlflow::Run* run) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete run_;
  }
  if (run) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      run = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, run, submessage_arena);
    }
    set_has_run();
  } else {
    clear_has_run();
  }
  run_ = run;
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.Response.run)
}

// -------------------------------------------------------------------

// CreateRun

// optional int64 experiment_id = 1;
inline bool CreateRun::has_experiment_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CreateRun::set_has_experiment_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CreateRun::clear_has_experiment_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CreateRun::clear_experiment_id() {
  experiment_id_ = GOOGLE_LONGLONG(0);
  clear_has_experiment_id();
}
inline ::google::protobuf::int64 CreateRun::experiment_id() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.experiment_id)
  return experiment_id_;
}
inline void CreateRun::set_experiment_id(::google::protobuf::int64 value) {
  set_has_experiment_id();
  experiment_id_ = value;
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.experiment_id)
}

// optional string user_id = 2;
inline bool CreateRun::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateRun::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateRun::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateRun::clear_user_id() {
  user_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user_id();
}
inline const ::std::string& CreateRun::user_id() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.user_id)
  return user_id_.GetNoArena();
}
inline void CreateRun::set_user_id(const ::std::string& value) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.user_id)
}
#if LANG_CXX11
inline void CreateRun::set_user_id(::std::string&& value) {
  set_has_user_id();
  user_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateRun.user_id)
}
#endif
inline void CreateRun::set_user_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateRun.user_id)
}
inline void CreateRun::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  user_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateRun.user_id)
}
inline ::std::string* CreateRun::mutable_user_id() {
  set_has_user_id();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.user_id)
  return user_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRun::release_user_id() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.user_id)
  if (!has_user_id()) {
    return NULL;
  }
  clear_has_user_id();
  return user_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRun::set_allocated_user_id(::std::string* user_id) {
  if (user_id != NULL) {
    set_has_user_id();
  } else {
    clear_has_user_id();
  }
  user_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user_id);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.user_id)
}

// optional string run_name = 3;
inline bool CreateRun::has_run_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateRun::set_has_run_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateRun::clear_has_run_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateRun::clear_run_name() {
  run_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_name();
}
inline const ::std::string& CreateRun::run_name() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.run_name)
  return run_name_.GetNoArena();
}
inline void CreateRun::set_run_name(const ::std::string& value) {
  set_has_run_name();
  run_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.run_name)
}
#if LANG_CXX11
inline void CreateRun::set_run_name(::std::string&& value) {
  set_has_run_name();
  run_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateRun.run_name)
}
#endif
inline void CreateRun::set_run_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_name();
  run_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateRun.run_name)
}
inline void CreateRun::set_run_name(const char* value, size_t size) {
  set_has_run_name();
  run_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateRun.run_name)
}
inline ::std::string* CreateRun::mutable_run_name() {
  set_has_run_name();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.run_name)
  return run_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRun::release_run_name() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.run_name)
  if (!has_run_name()) {
    return NULL;
  }
  clear_has_run_name();
  return run_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRun::set_allocated_run_name(::std::string* run_name) {
  if (run_name != NULL) {
    set_has_run_name();
  } else {
    clear_has_run_name();
  }
  run_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.run_name)
}

// optional .mlflow.SourceType source_type = 4;
inline bool CreateRun::has_source_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CreateRun::set_has_source_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CreateRun::clear_has_source_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CreateRun::clear_source_type() {
  source_type_ = 1;
  clear_has_source_type();
}
inline ::mlflow::SourceType CreateRun::source_type() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.source_type)
  return static_cast< ::mlflow::SourceType >(source_type_);
}
inline void CreateRun::set_source_type(::mlflow::SourceType value) {
  assert(::mlflow::SourceType_IsValid(value));
  set_has_source_type();
  source_type_ = value;
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.source_type)
}

// optional string source_name = 5;
inline bool CreateRun::has_source_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateRun::set_has_source_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateRun::clear_has_source_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateRun::clear_source_name() {
  source_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_name();
}
inline const ::std::string& CreateRun::source_name() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.source_name)
  return source_name_.GetNoArena();
}
inline void CreateRun::set_source_name(const ::std::string& value) {
  set_has_source_name();
  source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.source_name)
}
#if LANG_CXX11
inline void CreateRun::set_source_name(::std::string&& value) {
  set_has_source_name();
  source_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateRun.source_name)
}
#endif
inline void CreateRun::set_source_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_name();
  source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateRun.source_name)
}
inline void CreateRun::set_source_name(const char* value, size_t size) {
  set_has_source_name();
  source_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateRun.source_name)
}
inline ::std::string* CreateRun::mutable_source_name() {
  set_has_source_name();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.source_name)
  return source_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRun::release_source_name() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.source_name)
  if (!has_source_name()) {
    return NULL;
  }
  clear_has_source_name();
  return source_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRun::set_allocated_source_name(::std::string* source_name) {
  if (source_name != NULL) {
    set_has_source_name();
  } else {
    clear_has_source_name();
  }
  source_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.source_name)
}

// optional string entry_point_name = 6;
inline bool CreateRun::has_entry_point_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CreateRun::set_has_entry_point_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CreateRun::clear_has_entry_point_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CreateRun::clear_entry_point_name() {
  entry_point_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_entry_point_name();
}
inline const ::std::string& CreateRun::entry_point_name() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.entry_point_name)
  return entry_point_name_.GetNoArena();
}
inline void CreateRun::set_entry_point_name(const ::std::string& value) {
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.entry_point_name)
}
#if LANG_CXX11
inline void CreateRun::set_entry_point_name(::std::string&& value) {
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateRun.entry_point_name)
}
#endif
inline void CreateRun::set_entry_point_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateRun.entry_point_name)
}
inline void CreateRun::set_entry_point_name(const char* value, size_t size) {
  set_has_entry_point_name();
  entry_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateRun.entry_point_name)
}
inline ::std::string* CreateRun::mutable_entry_point_name() {
  set_has_entry_point_name();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.entry_point_name)
  return entry_point_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRun::release_entry_point_name() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.entry_point_name)
  if (!has_entry_point_name()) {
    return NULL;
  }
  clear_has_entry_point_name();
  return entry_point_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRun::set_allocated_entry_point_name(::std::string* entry_point_name) {
  if (entry_point_name != NULL) {
    set_has_entry_point_name();
  } else {
    clear_has_entry_point_name();
  }
  entry_point_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entry_point_name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.entry_point_name)
}

// optional int64 start_time = 7;
inline bool CreateRun::has_start_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CreateRun::set_has_start_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CreateRun::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CreateRun::clear_start_time() {
  start_time_ = GOOGLE_LONGLONG(0);
  clear_has_start_time();
}
inline ::google::protobuf::int64 CreateRun::start_time() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.start_time)
  return start_time_;
}
inline void CreateRun::set_start_time(::google::protobuf::int64 value) {
  set_has_start_time();
  start_time_ = value;
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.start_time)
}

// optional string source_version = 8;
inline bool CreateRun::has_source_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CreateRun::set_has_source_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CreateRun::clear_has_source_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CreateRun::clear_source_version() {
  source_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source_version();
}
inline const ::std::string& CreateRun::source_version() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.source_version)
  return source_version_.GetNoArena();
}
inline void CreateRun::set_source_version(const ::std::string& value) {
  set_has_source_version();
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.source_version)
}
#if LANG_CXX11
inline void CreateRun::set_source_version(::std::string&& value) {
  set_has_source_version();
  source_version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateRun.source_version)
}
#endif
inline void CreateRun::set_source_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_source_version();
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateRun.source_version)
}
inline void CreateRun::set_source_version(const char* value, size_t size) {
  set_has_source_version();
  source_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateRun.source_version)
}
inline ::std::string* CreateRun::mutable_source_version() {
  set_has_source_version();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.source_version)
  return source_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRun::release_source_version() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.source_version)
  if (!has_source_version()) {
    return NULL;
  }
  clear_has_source_version();
  return source_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRun::set_allocated_source_version(::std::string* source_version) {
  if (source_version != NULL) {
    set_has_source_version();
  } else {
    clear_has_source_version();
  }
  source_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source_version);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.source_version)
}

// repeated .mlflow.RunTag tags = 9;
inline int CreateRun::tags_size() const {
  return tags_.size();
}
inline void CreateRun::clear_tags() {
  tags_.Clear();
}
inline ::mlflow::RunTag* CreateRun::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.tags)
  return tags_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >*
CreateRun::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.CreateRun.tags)
  return &tags_;
}
inline const ::mlflow::RunTag& CreateRun::tags(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.tags)
  return tags_.Get(index);
}
inline ::mlflow::RunTag* CreateRun::add_tags() {
  // @@protoc_insertion_point(field_add:mlflow.CreateRun.tags)
  return tags_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::RunTag >&
CreateRun::tags() const {
  // @@protoc_insertion_point(field_list:mlflow.CreateRun.tags)
  return tags_;
}

// optional string parent_run_id = 10;
inline bool CreateRun::has_parent_run_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CreateRun::set_has_parent_run_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CreateRun::clear_has_parent_run_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CreateRun::clear_parent_run_id() {
  parent_run_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_parent_run_id();
}
inline const ::std::string& CreateRun::parent_run_id() const {
  // @@protoc_insertion_point(field_get:mlflow.CreateRun.parent_run_id)
  return parent_run_id_.GetNoArena();
}
inline void CreateRun::set_parent_run_id(const ::std::string& value) {
  set_has_parent_run_id();
  parent_run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.CreateRun.parent_run_id)
}
#if LANG_CXX11
inline void CreateRun::set_parent_run_id(::std::string&& value) {
  set_has_parent_run_id();
  parent_run_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.CreateRun.parent_run_id)
}
#endif
inline void CreateRun::set_parent_run_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_parent_run_id();
  parent_run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.CreateRun.parent_run_id)
}
inline void CreateRun::set_parent_run_id(const char* value, size_t size) {
  set_has_parent_run_id();
  parent_run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.CreateRun.parent_run_id)
}
inline ::std::string* CreateRun::mutable_parent_run_id() {
  set_has_parent_run_id();
  // @@protoc_insertion_point(field_mutable:mlflow.CreateRun.parent_run_id)
  return parent_run_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateRun::release_parent_run_id() {
  // @@protoc_insertion_point(field_release:mlflow.CreateRun.parent_run_id)
  if (!has_parent_run_id()) {
    return NULL;
  }
  clear_has_parent_run_id();
  return parent_run_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateRun::set_allocated_parent_run_id(::std::string* parent_run_id) {
  if (parent_run_id != NULL) {
    set_has_parent_run_id();
  } else {
    clear_has_parent_run_id();
  }
  parent_run_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), parent_run_id);
  // @@protoc_insertion_point(field_set_allocated:mlflow.CreateRun.parent_run_id)
}

// -------------------------------------------------------------------

// UpdateRun_Response

// optional .mlflow.RunInfo run_info = 1;
inline bool UpdateRun_Response::has_run_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateRun_Response::set_has_run_info() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateRun_Response::clear_has_run_info() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateRun_Response::clear_run_info() {
  if (run_info_ != NULL) run_info_->Clear();
  clear_has_run_info();
}
inline const ::mlflow::RunInfo& UpdateRun_Response::_internal_run_info() const {
  return *run_info_;
}
inline const ::mlflow::RunInfo& UpdateRun_Response::run_info() const {
  const ::mlflow::RunInfo* p = run_info_;
  // @@protoc_insertion_point(field_get:mlflow.UpdateRun.Response.run_info)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::RunInfo*>(
      &::mlflow::_RunInfo_default_instance_);
}
inline ::mlflow::RunInfo* UpdateRun_Response::release_run_info() {
  // @@protoc_insertion_point(field_release:mlflow.UpdateRun.Response.run_info)
  clear_has_run_info();
  ::mlflow::RunInfo* temp = run_info_;
  run_info_ = NULL;
  return temp;
}
inline ::mlflow::RunInfo* UpdateRun_Response::mutable_run_info() {
  set_has_run_info();
  if (run_info_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::RunInfo>(GetArenaNoVirtual());
    run_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.UpdateRun.Response.run_info)
  return run_info_;
}
inline void UpdateRun_Response::set_allocated_run_info(::mlflow::RunInfo* run_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete run_info_;
  }
  if (run_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      run_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, run_info, submessage_arena);
    }
    set_has_run_info();
  } else {
    clear_has_run_info();
  }
  run_info_ = run_info;
  // @@protoc_insertion_point(field_set_allocated:mlflow.UpdateRun.Response.run_info)
}

// -------------------------------------------------------------------

// UpdateRun

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool UpdateRun::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateRun::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateRun::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateRun::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& UpdateRun::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.UpdateRun.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void UpdateRun::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.UpdateRun.run_uuid)
}
#if LANG_CXX11
inline void UpdateRun::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.UpdateRun.run_uuid)
}
#endif
inline void UpdateRun::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.UpdateRun.run_uuid)
}
inline void UpdateRun::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.UpdateRun.run_uuid)
}
inline ::std::string* UpdateRun::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.UpdateRun.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UpdateRun::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.UpdateRun.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UpdateRun::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.UpdateRun.run_uuid)
}

// optional .mlflow.RunStatus status = 2;
inline bool UpdateRun::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateRun::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateRun::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateRun::clear_status() {
  status_ = 1;
  clear_has_status();
}
inline ::mlflow::RunStatus UpdateRun::status() const {
  // @@protoc_insertion_point(field_get:mlflow.UpdateRun.status)
  return static_cast< ::mlflow::RunStatus >(status_);
}
inline void UpdateRun::set_status(::mlflow::RunStatus value) {
  assert(::mlflow::RunStatus_IsValid(value));
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:mlflow.UpdateRun.status)
}

// optional int64 end_time = 3;
inline bool UpdateRun::has_end_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateRun::set_has_end_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateRun::clear_has_end_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateRun::clear_end_time() {
  end_time_ = GOOGLE_LONGLONG(0);
  clear_has_end_time();
}
inline ::google::protobuf::int64 UpdateRun::end_time() const {
  // @@protoc_insertion_point(field_get:mlflow.UpdateRun.end_time)
  return end_time_;
}
inline void UpdateRun::set_end_time(::google::protobuf::int64 value) {
  set_has_end_time();
  end_time_ = value;
  // @@protoc_insertion_point(field_set:mlflow.UpdateRun.end_time)
}

// -------------------------------------------------------------------

// DeleteRun_Response

// -------------------------------------------------------------------

// DeleteRun

// optional string run_id = 1 [(.validate_required) = true];
inline bool DeleteRun::has_run_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRun::set_has_run_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRun::clear_has_run_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRun::clear_run_id() {
  run_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_id();
}
inline const ::std::string& DeleteRun::run_id() const {
  // @@protoc_insertion_point(field_get:mlflow.DeleteRun.run_id)
  return run_id_.GetNoArena();
}
inline void DeleteRun::set_run_id(const ::std::string& value) {
  set_has_run_id();
  run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.DeleteRun.run_id)
}
#if LANG_CXX11
inline void DeleteRun::set_run_id(::std::string&& value) {
  set_has_run_id();
  run_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.DeleteRun.run_id)
}
#endif
inline void DeleteRun::set_run_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_id();
  run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.DeleteRun.run_id)
}
inline void DeleteRun::set_run_id(const char* value, size_t size) {
  set_has_run_id();
  run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.DeleteRun.run_id)
}
inline ::std::string* DeleteRun::mutable_run_id() {
  set_has_run_id();
  // @@protoc_insertion_point(field_mutable:mlflow.DeleteRun.run_id)
  return run_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRun::release_run_id() {
  // @@protoc_insertion_point(field_release:mlflow.DeleteRun.run_id)
  if (!has_run_id()) {
    return NULL;
  }
  clear_has_run_id();
  return run_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRun::set_allocated_run_id(::std::string* run_id) {
  if (run_id != NULL) {
    set_has_run_id();
  } else {
    clear_has_run_id();
  }
  run_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_id);
  // @@protoc_insertion_point(field_set_allocated:mlflow.DeleteRun.run_id)
}

// -------------------------------------------------------------------

// RestoreRun_Response

// -------------------------------------------------------------------

// RestoreRun

// optional string run_id = 1 [(.validate_required) = true];
inline bool RestoreRun::has_run_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RestoreRun::set_has_run_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RestoreRun::clear_has_run_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RestoreRun::clear_run_id() {
  run_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_id();
}
inline const ::std::string& RestoreRun::run_id() const {
  // @@protoc_insertion_point(field_get:mlflow.RestoreRun.run_id)
  return run_id_.GetNoArena();
}
inline void RestoreRun::set_run_id(const ::std::string& value) {
  set_has_run_id();
  run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.RestoreRun.run_id)
}
#if LANG_CXX11
inline void RestoreRun::set_run_id(::std::string&& value) {
  set_has_run_id();
  run_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.RestoreRun.run_id)
}
#endif
inline void RestoreRun::set_run_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_id();
  run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.RestoreRun.run_id)
}
inline void RestoreRun::set_run_id(const char* value, size_t size) {
  set_has_run_id();
  run_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.RestoreRun.run_id)
}
inline ::std::string* RestoreRun::mutable_run_id() {
  set_has_run_id();
  // @@protoc_insertion_point(field_mutable:mlflow.RestoreRun.run_id)
  return run_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RestoreRun::release_run_id() {
  // @@protoc_insertion_point(field_release:mlflow.RestoreRun.run_id)
  if (!has_run_id()) {
    return NULL;
  }
  clear_has_run_id();
  return run_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RestoreRun::set_allocated_run_id(::std::string* run_id) {
  if (run_id != NULL) {
    set_has_run_id();
  } else {
    clear_has_run_id();
  }
  run_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_id);
  // @@protoc_insertion_point(field_set_allocated:mlflow.RestoreRun.run_id)
}

// -------------------------------------------------------------------

// LogMetric_Response

// -------------------------------------------------------------------

// LogMetric

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool LogMetric::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogMetric::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogMetric::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogMetric::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& LogMetric::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.LogMetric.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void LogMetric::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.LogMetric.run_uuid)
}
#if LANG_CXX11
inline void LogMetric::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.LogMetric.run_uuid)
}
#endif
inline void LogMetric::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.LogMetric.run_uuid)
}
inline void LogMetric::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.LogMetric.run_uuid)
}
inline ::std::string* LogMetric::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.LogMetric.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMetric::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.LogMetric.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMetric::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.LogMetric.run_uuid)
}

// optional string key = 2 [(.validate_required) = true];
inline bool LogMetric::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogMetric::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogMetric::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogMetric::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& LogMetric::key() const {
  // @@protoc_insertion_point(field_get:mlflow.LogMetric.key)
  return key_.GetNoArena();
}
inline void LogMetric::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.LogMetric.key)
}
#if LANG_CXX11
inline void LogMetric::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.LogMetric.key)
}
#endif
inline void LogMetric::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.LogMetric.key)
}
inline void LogMetric::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.LogMetric.key)
}
inline ::std::string* LogMetric::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.LogMetric.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogMetric::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.LogMetric.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogMetric::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.LogMetric.key)
}

// optional double value = 3 [(.validate_required) = true];
inline bool LogMetric::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogMetric::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogMetric::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogMetric::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double LogMetric::value() const {
  // @@protoc_insertion_point(field_get:mlflow.LogMetric.value)
  return value_;
}
inline void LogMetric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mlflow.LogMetric.value)
}

// optional int64 timestamp = 4 [(.validate_required) = true];
inline bool LogMetric::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LogMetric::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LogMetric::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LogMetric::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 LogMetric::timestamp() const {
  // @@protoc_insertion_point(field_get:mlflow.LogMetric.timestamp)
  return timestamp_;
}
inline void LogMetric::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mlflow.LogMetric.timestamp)
}

// -------------------------------------------------------------------

// LogParam_Response

// -------------------------------------------------------------------

// LogParam

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool LogParam::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogParam::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogParam::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogParam::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& LogParam::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.LogParam.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void LogParam::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.LogParam.run_uuid)
}
#if LANG_CXX11
inline void LogParam::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.LogParam.run_uuid)
}
#endif
inline void LogParam::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.LogParam.run_uuid)
}
inline void LogParam::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.LogParam.run_uuid)
}
inline ::std::string* LogParam::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.LogParam.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogParam::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.LogParam.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogParam::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.LogParam.run_uuid)
}

// optional string key = 2 [(.validate_required) = true];
inline bool LogParam::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogParam::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogParam::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogParam::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& LogParam::key() const {
  // @@protoc_insertion_point(field_get:mlflow.LogParam.key)
  return key_.GetNoArena();
}
inline void LogParam::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.LogParam.key)
}
#if LANG_CXX11
inline void LogParam::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.LogParam.key)
}
#endif
inline void LogParam::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.LogParam.key)
}
inline void LogParam::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.LogParam.key)
}
inline ::std::string* LogParam::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.LogParam.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogParam::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.LogParam.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogParam::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.LogParam.key)
}

// optional string value = 3 [(.validate_required) = true];
inline bool LogParam::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LogParam::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LogParam::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LogParam::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& LogParam::value() const {
  // @@protoc_insertion_point(field_get:mlflow.LogParam.value)
  return value_.GetNoArena();
}
inline void LogParam::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.LogParam.value)
}
#if LANG_CXX11
inline void LogParam::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.LogParam.value)
}
#endif
inline void LogParam::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.LogParam.value)
}
inline void LogParam::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.LogParam.value)
}
inline ::std::string* LogParam::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mlflow.LogParam.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogParam::release_value() {
  // @@protoc_insertion_point(field_release:mlflow.LogParam.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogParam::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mlflow.LogParam.value)
}

// -------------------------------------------------------------------

// SetTag_Response

// -------------------------------------------------------------------

// SetTag

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool SetTag::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SetTag::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SetTag::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SetTag::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& SetTag::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.SetTag.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void SetTag::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.SetTag.run_uuid)
}
#if LANG_CXX11
inline void SetTag::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.SetTag.run_uuid)
}
#endif
inline void SetTag::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.SetTag.run_uuid)
}
inline void SetTag::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.SetTag.run_uuid)
}
inline ::std::string* SetTag::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.SetTag.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetTag::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.SetTag.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetTag::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.SetTag.run_uuid)
}

// optional string key = 2 [(.validate_required) = true];
inline bool SetTag::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SetTag::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SetTag::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SetTag::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& SetTag::key() const {
  // @@protoc_insertion_point(field_get:mlflow.SetTag.key)
  return key_.GetNoArena();
}
inline void SetTag::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.SetTag.key)
}
#if LANG_CXX11
inline void SetTag::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.SetTag.key)
}
#endif
inline void SetTag::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.SetTag.key)
}
inline void SetTag::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.SetTag.key)
}
inline ::std::string* SetTag::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.SetTag.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetTag::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.SetTag.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetTag::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.SetTag.key)
}

// optional string value = 3 [(.validate_required) = true];
inline bool SetTag::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SetTag::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SetTag::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SetTag::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& SetTag::value() const {
  // @@protoc_insertion_point(field_get:mlflow.SetTag.value)
  return value_.GetNoArena();
}
inline void SetTag::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.SetTag.value)
}
#if LANG_CXX11
inline void SetTag::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.SetTag.value)
}
#endif
inline void SetTag::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.SetTag.value)
}
inline void SetTag::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.SetTag.value)
}
inline ::std::string* SetTag::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mlflow.SetTag.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SetTag::release_value() {
  // @@protoc_insertion_point(field_release:mlflow.SetTag.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SetTag::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mlflow.SetTag.value)
}

// -------------------------------------------------------------------

// GetRun_Response

// optional .mlflow.Run run = 1;
inline bool GetRun_Response::has_run() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRun_Response::set_has_run() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRun_Response::clear_has_run() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRun_Response::clear_run() {
  if (run_ != NULL) run_->Clear();
  clear_has_run();
}
inline const ::mlflow::Run& GetRun_Response::_internal_run() const {
  return *run_;
}
inline const ::mlflow::Run& GetRun_Response::run() const {
  const ::mlflow::Run* p = run_;
  // @@protoc_insertion_point(field_get:mlflow.GetRun.Response.run)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::Run*>(
      &::mlflow::_Run_default_instance_);
}
inline ::mlflow::Run* GetRun_Response::release_run() {
  // @@protoc_insertion_point(field_release:mlflow.GetRun.Response.run)
  clear_has_run();
  ::mlflow::Run* temp = run_;
  run_ = NULL;
  return temp;
}
inline ::mlflow::Run* GetRun_Response::mutable_run() {
  set_has_run();
  if (run_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::Run>(GetArenaNoVirtual());
    run_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.GetRun.Response.run)
  return run_;
}
inline void GetRun_Response::set_allocated_run(::mlflow::Run* run) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete run_;
  }
  if (run) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      run = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, run, submessage_arena);
    }
    set_has_run();
  } else {
    clear_has_run();
  }
  run_ = run;
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetRun.Response.run)
}

// -------------------------------------------------------------------

// GetRun

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool GetRun::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetRun::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetRun::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetRun::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& GetRun::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.GetRun.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void GetRun::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetRun.run_uuid)
}
#if LANG_CXX11
inline void GetRun::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetRun.run_uuid)
}
#endif
inline void GetRun::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetRun.run_uuid)
}
inline void GetRun::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetRun.run_uuid)
}
inline ::std::string* GetRun::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.GetRun.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetRun::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.GetRun.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetRun::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetRun.run_uuid)
}

// -------------------------------------------------------------------

// GetMetric_Response

// optional .mlflow.Metric metric = 1;
inline bool GetMetric_Response::has_metric() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMetric_Response::set_has_metric() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMetric_Response::clear_has_metric() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMetric_Response::clear_metric() {
  if (metric_ != NULL) metric_->Clear();
  clear_has_metric();
}
inline const ::mlflow::Metric& GetMetric_Response::_internal_metric() const {
  return *metric_;
}
inline const ::mlflow::Metric& GetMetric_Response::metric() const {
  const ::mlflow::Metric* p = metric_;
  // @@protoc_insertion_point(field_get:mlflow.GetMetric.Response.metric)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::Metric*>(
      &::mlflow::_Metric_default_instance_);
}
inline ::mlflow::Metric* GetMetric_Response::release_metric() {
  // @@protoc_insertion_point(field_release:mlflow.GetMetric.Response.metric)
  clear_has_metric();
  ::mlflow::Metric* temp = metric_;
  metric_ = NULL;
  return temp;
}
inline ::mlflow::Metric* GetMetric_Response::mutable_metric() {
  set_has_metric();
  if (metric_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::Metric>(GetArenaNoVirtual());
    metric_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.GetMetric.Response.metric)
  return metric_;
}
inline void GetMetric_Response::set_allocated_metric(::mlflow::Metric* metric) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete metric_;
  }
  if (metric) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metric = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metric, submessage_arena);
    }
    set_has_metric();
  } else {
    clear_has_metric();
  }
  metric_ = metric;
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetMetric.Response.metric)
}

// -------------------------------------------------------------------

// GetMetric

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool GetMetric::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMetric::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMetric::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMetric::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& GetMetric::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.GetMetric.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void GetMetric::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetMetric.run_uuid)
}
#if LANG_CXX11
inline void GetMetric::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetMetric.run_uuid)
}
#endif
inline void GetMetric::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetMetric.run_uuid)
}
inline void GetMetric::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetMetric.run_uuid)
}
inline ::std::string* GetMetric::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.GetMetric.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMetric::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.GetMetric.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMetric::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetMetric.run_uuid)
}

// optional string metric_key = 2 [(.validate_required) = true];
inline bool GetMetric::has_metric_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMetric::set_has_metric_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMetric::clear_has_metric_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMetric::clear_metric_key() {
  metric_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metric_key();
}
inline const ::std::string& GetMetric::metric_key() const {
  // @@protoc_insertion_point(field_get:mlflow.GetMetric.metric_key)
  return metric_key_.GetNoArena();
}
inline void GetMetric::set_metric_key(const ::std::string& value) {
  set_has_metric_key();
  metric_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetMetric.metric_key)
}
#if LANG_CXX11
inline void GetMetric::set_metric_key(::std::string&& value) {
  set_has_metric_key();
  metric_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetMetric.metric_key)
}
#endif
inline void GetMetric::set_metric_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metric_key();
  metric_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetMetric.metric_key)
}
inline void GetMetric::set_metric_key(const char* value, size_t size) {
  set_has_metric_key();
  metric_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetMetric.metric_key)
}
inline ::std::string* GetMetric::mutable_metric_key() {
  set_has_metric_key();
  // @@protoc_insertion_point(field_mutable:mlflow.GetMetric.metric_key)
  return metric_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMetric::release_metric_key() {
  // @@protoc_insertion_point(field_release:mlflow.GetMetric.metric_key)
  if (!has_metric_key()) {
    return NULL;
  }
  clear_has_metric_key();
  return metric_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMetric::set_allocated_metric_key(::std::string* metric_key) {
  if (metric_key != NULL) {
    set_has_metric_key();
  } else {
    clear_has_metric_key();
  }
  metric_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metric_key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetMetric.metric_key)
}

// -------------------------------------------------------------------

// GetParam_Response

// optional .mlflow.Param parameter = 1;
inline bool GetParam_Response::has_parameter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetParam_Response::set_has_parameter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetParam_Response::clear_has_parameter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetParam_Response::clear_parameter() {
  if (parameter_ != NULL) parameter_->Clear();
  clear_has_parameter();
}
inline const ::mlflow::Param& GetParam_Response::_internal_parameter() const {
  return *parameter_;
}
inline const ::mlflow::Param& GetParam_Response::parameter() const {
  const ::mlflow::Param* p = parameter_;
  // @@protoc_insertion_point(field_get:mlflow.GetParam.Response.parameter)
  return p != NULL ? *p : *reinterpret_cast<const ::mlflow::Param*>(
      &::mlflow::_Param_default_instance_);
}
inline ::mlflow::Param* GetParam_Response::release_parameter() {
  // @@protoc_insertion_point(field_release:mlflow.GetParam.Response.parameter)
  clear_has_parameter();
  ::mlflow::Param* temp = parameter_;
  parameter_ = NULL;
  return temp;
}
inline ::mlflow::Param* GetParam_Response::mutable_parameter() {
  set_has_parameter();
  if (parameter_ == NULL) {
    auto* p = CreateMaybeMessage<::mlflow::Param>(GetArenaNoVirtual());
    parameter_ = p;
  }
  // @@protoc_insertion_point(field_mutable:mlflow.GetParam.Response.parameter)
  return parameter_;
}
inline void GetParam_Response::set_allocated_parameter(::mlflow::Param* parameter) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete parameter_;
  }
  if (parameter) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      parameter = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, parameter, submessage_arena);
    }
    set_has_parameter();
  } else {
    clear_has_parameter();
  }
  parameter_ = parameter;
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetParam.Response.parameter)
}

// -------------------------------------------------------------------

// GetParam

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool GetParam::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetParam::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetParam::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetParam::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& GetParam::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.GetParam.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void GetParam::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetParam.run_uuid)
}
#if LANG_CXX11
inline void GetParam::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetParam.run_uuid)
}
#endif
inline void GetParam::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetParam.run_uuid)
}
inline void GetParam::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetParam.run_uuid)
}
inline ::std::string* GetParam::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.GetParam.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetParam::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.GetParam.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetParam::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetParam.run_uuid)
}

// optional string param_name = 2 [(.validate_required) = true];
inline bool GetParam::has_param_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetParam::set_has_param_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetParam::clear_has_param_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetParam::clear_param_name() {
  param_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_param_name();
}
inline const ::std::string& GetParam::param_name() const {
  // @@protoc_insertion_point(field_get:mlflow.GetParam.param_name)
  return param_name_.GetNoArena();
}
inline void GetParam::set_param_name(const ::std::string& value) {
  set_has_param_name();
  param_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetParam.param_name)
}
#if LANG_CXX11
inline void GetParam::set_param_name(::std::string&& value) {
  set_has_param_name();
  param_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetParam.param_name)
}
#endif
inline void GetParam::set_param_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_param_name();
  param_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetParam.param_name)
}
inline void GetParam::set_param_name(const char* value, size_t size) {
  set_has_param_name();
  param_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetParam.param_name)
}
inline ::std::string* GetParam::mutable_param_name() {
  set_has_param_name();
  // @@protoc_insertion_point(field_mutable:mlflow.GetParam.param_name)
  return param_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetParam::release_param_name() {
  // @@protoc_insertion_point(field_release:mlflow.GetParam.param_name)
  if (!has_param_name()) {
    return NULL;
  }
  clear_has_param_name();
  return param_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetParam::set_allocated_param_name(::std::string* param_name) {
  if (param_name != NULL) {
    set_has_param_name();
  } else {
    clear_has_param_name();
  }
  param_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), param_name);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetParam.param_name)
}

// -------------------------------------------------------------------

// SearchExpression

// optional .mlflow.MetricSearchExpression metric = 1;
inline bool SearchExpression::has_metric() const {
  return expression_case() == kMetric;
}
inline void SearchExpression::set_has_metric() {
  _oneof_case_[0] = kMetric;
}
inline void SearchExpression::clear_metric() {
  if (has_metric()) {
    delete expression_.metric_;
    clear_has_expression();
  }
}
inline const ::mlflow::MetricSearchExpression& SearchExpression::_internal_metric() const {
  return *expression_.metric_;
}
inline ::mlflow::MetricSearchExpression* SearchExpression::release_metric() {
  // @@protoc_insertion_point(field_release:mlflow.SearchExpression.metric)
  if (has_metric()) {
    clear_has_expression();
      ::mlflow::MetricSearchExpression* temp = expression_.metric_;
    expression_.metric_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mlflow::MetricSearchExpression& SearchExpression::metric() const {
  // @@protoc_insertion_point(field_get:mlflow.SearchExpression.metric)
  return has_metric()
      ? *expression_.metric_
      : *reinterpret_cast< ::mlflow::MetricSearchExpression*>(&::mlflow::_MetricSearchExpression_default_instance_);
}
inline ::mlflow::MetricSearchExpression* SearchExpression::mutable_metric() {
  if (!has_metric()) {
    clear_expression();
    set_has_metric();
    expression_.metric_ = CreateMaybeMessage< ::mlflow::MetricSearchExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mlflow.SearchExpression.metric)
  return expression_.metric_;
}

// optional .mlflow.ParameterSearchExpression parameter = 2;
inline bool SearchExpression::has_parameter() const {
  return expression_case() == kParameter;
}
inline void SearchExpression::set_has_parameter() {
  _oneof_case_[0] = kParameter;
}
inline void SearchExpression::clear_parameter() {
  if (has_parameter()) {
    delete expression_.parameter_;
    clear_has_expression();
  }
}
inline const ::mlflow::ParameterSearchExpression& SearchExpression::_internal_parameter() const {
  return *expression_.parameter_;
}
inline ::mlflow::ParameterSearchExpression* SearchExpression::release_parameter() {
  // @@protoc_insertion_point(field_release:mlflow.SearchExpression.parameter)
  if (has_parameter()) {
    clear_has_expression();
      ::mlflow::ParameterSearchExpression* temp = expression_.parameter_;
    expression_.parameter_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mlflow::ParameterSearchExpression& SearchExpression::parameter() const {
  // @@protoc_insertion_point(field_get:mlflow.SearchExpression.parameter)
  return has_parameter()
      ? *expression_.parameter_
      : *reinterpret_cast< ::mlflow::ParameterSearchExpression*>(&::mlflow::_ParameterSearchExpression_default_instance_);
}
inline ::mlflow::ParameterSearchExpression* SearchExpression::mutable_parameter() {
  if (!has_parameter()) {
    clear_expression();
    set_has_parameter();
    expression_.parameter_ = CreateMaybeMessage< ::mlflow::ParameterSearchExpression >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mlflow.SearchExpression.parameter)
  return expression_.parameter_;
}

inline bool SearchExpression::has_expression() const {
  return expression_case() != EXPRESSION_NOT_SET;
}
inline void SearchExpression::clear_has_expression() {
  _oneof_case_[0] = EXPRESSION_NOT_SET;
}
inline SearchExpression::ExpressionCase SearchExpression::expression_case() const {
  return SearchExpression::ExpressionCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// MetricSearchExpression

// optional string key = 1;
inline bool MetricSearchExpression::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MetricSearchExpression::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MetricSearchExpression::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MetricSearchExpression::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& MetricSearchExpression::key() const {
  // @@protoc_insertion_point(field_get:mlflow.MetricSearchExpression.key)
  return key_.GetNoArena();
}
inline void MetricSearchExpression::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.MetricSearchExpression.key)
}
#if LANG_CXX11
inline void MetricSearchExpression::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.MetricSearchExpression.key)
}
#endif
inline void MetricSearchExpression::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.MetricSearchExpression.key)
}
inline void MetricSearchExpression::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.MetricSearchExpression.key)
}
inline ::std::string* MetricSearchExpression::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.MetricSearchExpression.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MetricSearchExpression::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.MetricSearchExpression.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MetricSearchExpression::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.MetricSearchExpression.key)
}

// optional .mlflow.FloatClause float = 2;
inline bool MetricSearchExpression::has_float_() const {
  return clause_case() == kFloat;
}
inline void MetricSearchExpression::set_has_float_() {
  _oneof_case_[0] = kFloat;
}
inline void MetricSearchExpression::clear_float_() {
  if (has_float_()) {
    delete clause_.float__;
    clear_has_clause();
  }
}
inline const ::mlflow::FloatClause& MetricSearchExpression::_internal_float_() const {
  return *clause_.float__;
}
inline ::mlflow::FloatClause* MetricSearchExpression::release_float_() {
  // @@protoc_insertion_point(field_release:mlflow.MetricSearchExpression.float)
  if (has_float_()) {
    clear_has_clause();
      ::mlflow::FloatClause* temp = clause_.float__;
    clause_.float__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mlflow::FloatClause& MetricSearchExpression::float_() const {
  // @@protoc_insertion_point(field_get:mlflow.MetricSearchExpression.float)
  return has_float_()
      ? *clause_.float__
      : *reinterpret_cast< ::mlflow::FloatClause*>(&::mlflow::_FloatClause_default_instance_);
}
inline ::mlflow::FloatClause* MetricSearchExpression::mutable_float_() {
  if (!has_float_()) {
    clear_clause();
    set_has_float_();
    clause_.float__ = CreateMaybeMessage< ::mlflow::FloatClause >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mlflow.MetricSearchExpression.float)
  return clause_.float__;
}

// optional .mlflow.DoubleClause double = 3;
inline bool MetricSearchExpression::has_double_() const {
  return clause_case() == kDouble;
}
inline void MetricSearchExpression::set_has_double_() {
  _oneof_case_[0] = kDouble;
}
inline void MetricSearchExpression::clear_double_() {
  if (has_double_()) {
    delete clause_.double__;
    clear_has_clause();
  }
}
inline const ::mlflow::DoubleClause& MetricSearchExpression::_internal_double_() const {
  return *clause_.double__;
}
inline ::mlflow::DoubleClause* MetricSearchExpression::release_double_() {
  // @@protoc_insertion_point(field_release:mlflow.MetricSearchExpression.double)
  if (has_double_()) {
    clear_has_clause();
      ::mlflow::DoubleClause* temp = clause_.double__;
    clause_.double__ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mlflow::DoubleClause& MetricSearchExpression::double_() const {
  // @@protoc_insertion_point(field_get:mlflow.MetricSearchExpression.double)
  return has_double_()
      ? *clause_.double__
      : *reinterpret_cast< ::mlflow::DoubleClause*>(&::mlflow::_DoubleClause_default_instance_);
}
inline ::mlflow::DoubleClause* MetricSearchExpression::mutable_double_() {
  if (!has_double_()) {
    clear_clause();
    set_has_double_();
    clause_.double__ = CreateMaybeMessage< ::mlflow::DoubleClause >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mlflow.MetricSearchExpression.double)
  return clause_.double__;
}

inline bool MetricSearchExpression::has_clause() const {
  return clause_case() != CLAUSE_NOT_SET;
}
inline void MetricSearchExpression::clear_has_clause() {
  _oneof_case_[0] = CLAUSE_NOT_SET;
}
inline MetricSearchExpression::ClauseCase MetricSearchExpression::clause_case() const {
  return MetricSearchExpression::ClauseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ParameterSearchExpression

// optional string key = 1;
inline bool ParameterSearchExpression::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParameterSearchExpression::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParameterSearchExpression::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParameterSearchExpression::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
inline const ::std::string& ParameterSearchExpression::key() const {
  // @@protoc_insertion_point(field_get:mlflow.ParameterSearchExpression.key)
  return key_.GetNoArena();
}
inline void ParameterSearchExpression::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.ParameterSearchExpression.key)
}
#if LANG_CXX11
inline void ParameterSearchExpression::set_key(::std::string&& value) {
  set_has_key();
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.ParameterSearchExpression.key)
}
#endif
inline void ParameterSearchExpression::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.ParameterSearchExpression.key)
}
inline void ParameterSearchExpression::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.ParameterSearchExpression.key)
}
inline ::std::string* ParameterSearchExpression::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mlflow.ParameterSearchExpression.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ParameterSearchExpression::release_key() {
  // @@protoc_insertion_point(field_release:mlflow.ParameterSearchExpression.key)
  if (!has_key()) {
    return NULL;
  }
  clear_has_key();
  return key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ParameterSearchExpression::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.ParameterSearchExpression.key)
}

// optional .mlflow.StringClause string = 2;
inline bool ParameterSearchExpression::has_string() const {
  return clause_case() == kString;
}
inline void ParameterSearchExpression::set_has_string() {
  _oneof_case_[0] = kString;
}
inline void ParameterSearchExpression::clear_string() {
  if (has_string()) {
    delete clause_.string_;
    clear_has_clause();
  }
}
inline const ::mlflow::StringClause& ParameterSearchExpression::_internal_string() const {
  return *clause_.string_;
}
inline ::mlflow::StringClause* ParameterSearchExpression::release_string() {
  // @@protoc_insertion_point(field_release:mlflow.ParameterSearchExpression.string)
  if (has_string()) {
    clear_has_clause();
      ::mlflow::StringClause* temp = clause_.string_;
    clause_.string_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::mlflow::StringClause& ParameterSearchExpression::string() const {
  // @@protoc_insertion_point(field_get:mlflow.ParameterSearchExpression.string)
  return has_string()
      ? *clause_.string_
      : *reinterpret_cast< ::mlflow::StringClause*>(&::mlflow::_StringClause_default_instance_);
}
inline ::mlflow::StringClause* ParameterSearchExpression::mutable_string() {
  if (!has_string()) {
    clear_clause();
    set_has_string();
    clause_.string_ = CreateMaybeMessage< ::mlflow::StringClause >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:mlflow.ParameterSearchExpression.string)
  return clause_.string_;
}

inline bool ParameterSearchExpression::has_clause() const {
  return clause_case() != CLAUSE_NOT_SET;
}
inline void ParameterSearchExpression::clear_has_clause() {
  _oneof_case_[0] = CLAUSE_NOT_SET;
}
inline ParameterSearchExpression::ClauseCase ParameterSearchExpression::clause_case() const {
  return ParameterSearchExpression::ClauseCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StringClause

// optional string comparator = 1;
inline bool StringClause::has_comparator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringClause::set_has_comparator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StringClause::clear_has_comparator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StringClause::clear_comparator() {
  comparator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comparator();
}
inline const ::std::string& StringClause::comparator() const {
  // @@protoc_insertion_point(field_get:mlflow.StringClause.comparator)
  return comparator_.GetNoArena();
}
inline void StringClause::set_comparator(const ::std::string& value) {
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.StringClause.comparator)
}
#if LANG_CXX11
inline void StringClause::set_comparator(::std::string&& value) {
  set_has_comparator();
  comparator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.StringClause.comparator)
}
#endif
inline void StringClause::set_comparator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.StringClause.comparator)
}
inline void StringClause::set_comparator(const char* value, size_t size) {
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.StringClause.comparator)
}
inline ::std::string* StringClause::mutable_comparator() {
  set_has_comparator();
  // @@protoc_insertion_point(field_mutable:mlflow.StringClause.comparator)
  return comparator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringClause::release_comparator() {
  // @@protoc_insertion_point(field_release:mlflow.StringClause.comparator)
  if (!has_comparator()) {
    return NULL;
  }
  clear_has_comparator();
  return comparator_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringClause::set_allocated_comparator(::std::string* comparator) {
  if (comparator != NULL) {
    set_has_comparator();
  } else {
    clear_has_comparator();
  }
  comparator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comparator);
  // @@protoc_insertion_point(field_set_allocated:mlflow.StringClause.comparator)
}

// optional string value = 2;
inline bool StringClause::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StringClause::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StringClause::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StringClause::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
inline const ::std::string& StringClause::value() const {
  // @@protoc_insertion_point(field_get:mlflow.StringClause.value)
  return value_.GetNoArena();
}
inline void StringClause::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.StringClause.value)
}
#if LANG_CXX11
inline void StringClause::set_value(::std::string&& value) {
  set_has_value();
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.StringClause.value)
}
#endif
inline void StringClause::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.StringClause.value)
}
inline void StringClause::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.StringClause.value)
}
inline ::std::string* StringClause::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mlflow.StringClause.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringClause::release_value() {
  // @@protoc_insertion_point(field_release:mlflow.StringClause.value)
  if (!has_value()) {
    return NULL;
  }
  clear_has_value();
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringClause::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mlflow.StringClause.value)
}

// -------------------------------------------------------------------

// FloatClause

// optional string comparator = 1;
inline bool FloatClause::has_comparator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatClause::set_has_comparator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FloatClause::clear_has_comparator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FloatClause::clear_comparator() {
  comparator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comparator();
}
inline const ::std::string& FloatClause::comparator() const {
  // @@protoc_insertion_point(field_get:mlflow.FloatClause.comparator)
  return comparator_.GetNoArena();
}
inline void FloatClause::set_comparator(const ::std::string& value) {
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.FloatClause.comparator)
}
#if LANG_CXX11
inline void FloatClause::set_comparator(::std::string&& value) {
  set_has_comparator();
  comparator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.FloatClause.comparator)
}
#endif
inline void FloatClause::set_comparator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.FloatClause.comparator)
}
inline void FloatClause::set_comparator(const char* value, size_t size) {
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.FloatClause.comparator)
}
inline ::std::string* FloatClause::mutable_comparator() {
  set_has_comparator();
  // @@protoc_insertion_point(field_mutable:mlflow.FloatClause.comparator)
  return comparator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FloatClause::release_comparator() {
  // @@protoc_insertion_point(field_release:mlflow.FloatClause.comparator)
  if (!has_comparator()) {
    return NULL;
  }
  clear_has_comparator();
  return comparator_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FloatClause::set_allocated_comparator(::std::string* comparator) {
  if (comparator != NULL) {
    set_has_comparator();
  } else {
    clear_has_comparator();
  }
  comparator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comparator);
  // @@protoc_insertion_point(field_set_allocated:mlflow.FloatClause.comparator)
}

// optional float value = 2;
inline bool FloatClause::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FloatClause::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FloatClause::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FloatClause::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline float FloatClause::value() const {
  // @@protoc_insertion_point(field_get:mlflow.FloatClause.value)
  return value_;
}
inline void FloatClause::set_value(float value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mlflow.FloatClause.value)
}

// -------------------------------------------------------------------

// DoubleClause

// optional string comparator = 1;
inline bool DoubleClause::has_comparator() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleClause::set_has_comparator() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleClause::clear_has_comparator() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleClause::clear_comparator() {
  comparator_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_comparator();
}
inline const ::std::string& DoubleClause::comparator() const {
  // @@protoc_insertion_point(field_get:mlflow.DoubleClause.comparator)
  return comparator_.GetNoArena();
}
inline void DoubleClause::set_comparator(const ::std::string& value) {
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.DoubleClause.comparator)
}
#if LANG_CXX11
inline void DoubleClause::set_comparator(::std::string&& value) {
  set_has_comparator();
  comparator_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.DoubleClause.comparator)
}
#endif
inline void DoubleClause::set_comparator(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.DoubleClause.comparator)
}
inline void DoubleClause::set_comparator(const char* value, size_t size) {
  set_has_comparator();
  comparator_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.DoubleClause.comparator)
}
inline ::std::string* DoubleClause::mutable_comparator() {
  set_has_comparator();
  // @@protoc_insertion_point(field_mutable:mlflow.DoubleClause.comparator)
  return comparator_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DoubleClause::release_comparator() {
  // @@protoc_insertion_point(field_release:mlflow.DoubleClause.comparator)
  if (!has_comparator()) {
    return NULL;
  }
  clear_has_comparator();
  return comparator_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DoubleClause::set_allocated_comparator(::std::string* comparator) {
  if (comparator != NULL) {
    set_has_comparator();
  } else {
    clear_has_comparator();
  }
  comparator_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), comparator);
  // @@protoc_insertion_point(field_set_allocated:mlflow.DoubleClause.comparator)
}

// optional double value = 2;
inline bool DoubleClause::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleClause::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleClause::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleClause::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double DoubleClause::value() const {
  // @@protoc_insertion_point(field_get:mlflow.DoubleClause.value)
  return value_;
}
inline void DoubleClause::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mlflow.DoubleClause.value)
}

// -------------------------------------------------------------------

// SearchRuns_Response

// repeated .mlflow.Run runs = 1;
inline int SearchRuns_Response::runs_size() const {
  return runs_.size();
}
inline void SearchRuns_Response::clear_runs() {
  runs_.Clear();
}
inline ::mlflow::Run* SearchRuns_Response::mutable_runs(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.SearchRuns.Response.runs)
  return runs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::Run >*
SearchRuns_Response::mutable_runs() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.SearchRuns.Response.runs)
  return &runs_;
}
inline const ::mlflow::Run& SearchRuns_Response::runs(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.SearchRuns.Response.runs)
  return runs_.Get(index);
}
inline ::mlflow::Run* SearchRuns_Response::add_runs() {
  // @@protoc_insertion_point(field_add:mlflow.SearchRuns.Response.runs)
  return runs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::Run >&
SearchRuns_Response::runs() const {
  // @@protoc_insertion_point(field_list:mlflow.SearchRuns.Response.runs)
  return runs_;
}

// -------------------------------------------------------------------

// SearchRuns

// repeated int64 experiment_ids = 1;
inline int SearchRuns::experiment_ids_size() const {
  return experiment_ids_.size();
}
inline void SearchRuns::clear_experiment_ids() {
  experiment_ids_.Clear();
}
inline ::google::protobuf::int64 SearchRuns::experiment_ids(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.SearchRuns.experiment_ids)
  return experiment_ids_.Get(index);
}
inline void SearchRuns::set_experiment_ids(int index, ::google::protobuf::int64 value) {
  experiment_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:mlflow.SearchRuns.experiment_ids)
}
inline void SearchRuns::add_experiment_ids(::google::protobuf::int64 value) {
  experiment_ids_.Add(value);
  // @@protoc_insertion_point(field_add:mlflow.SearchRuns.experiment_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
SearchRuns::experiment_ids() const {
  // @@protoc_insertion_point(field_list:mlflow.SearchRuns.experiment_ids)
  return experiment_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
SearchRuns::mutable_experiment_ids() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.SearchRuns.experiment_ids)
  return &experiment_ids_;
}

// repeated .mlflow.SearchExpression anded_expressions = 2;
inline int SearchRuns::anded_expressions_size() const {
  return anded_expressions_.size();
}
inline void SearchRuns::clear_anded_expressions() {
  anded_expressions_.Clear();
}
inline ::mlflow::SearchExpression* SearchRuns::mutable_anded_expressions(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.SearchRuns.anded_expressions)
  return anded_expressions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::SearchExpression >*
SearchRuns::mutable_anded_expressions() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.SearchRuns.anded_expressions)
  return &anded_expressions_;
}
inline const ::mlflow::SearchExpression& SearchRuns::anded_expressions(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.SearchRuns.anded_expressions)
  return anded_expressions_.Get(index);
}
inline ::mlflow::SearchExpression* SearchRuns::add_anded_expressions() {
  // @@protoc_insertion_point(field_add:mlflow.SearchRuns.anded_expressions)
  return anded_expressions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::SearchExpression >&
SearchRuns::anded_expressions() const {
  // @@protoc_insertion_point(field_list:mlflow.SearchRuns.anded_expressions)
  return anded_expressions_;
}

// optional .mlflow.ViewType run_view_type = 3 [default = ACTIVE_ONLY];
inline bool SearchRuns::has_run_view_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchRuns::set_has_run_view_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchRuns::clear_has_run_view_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchRuns::clear_run_view_type() {
  run_view_type_ = 1;
  clear_has_run_view_type();
}
inline ::mlflow::ViewType SearchRuns::run_view_type() const {
  // @@protoc_insertion_point(field_get:mlflow.SearchRuns.run_view_type)
  return static_cast< ::mlflow::ViewType >(run_view_type_);
}
inline void SearchRuns::set_run_view_type(::mlflow::ViewType value) {
  assert(::mlflow::ViewType_IsValid(value));
  set_has_run_view_type();
  run_view_type_ = value;
  // @@protoc_insertion_point(field_set:mlflow.SearchRuns.run_view_type)
}

// -------------------------------------------------------------------

// ListArtifacts_Response

// optional string root_uri = 1;
inline bool ListArtifacts_Response::has_root_uri() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListArtifacts_Response::set_has_root_uri() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListArtifacts_Response::clear_has_root_uri() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListArtifacts_Response::clear_root_uri() {
  root_uri_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_root_uri();
}
inline const ::std::string& ListArtifacts_Response::root_uri() const {
  // @@protoc_insertion_point(field_get:mlflow.ListArtifacts.Response.root_uri)
  return root_uri_.GetNoArena();
}
inline void ListArtifacts_Response::set_root_uri(const ::std::string& value) {
  set_has_root_uri();
  root_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.ListArtifacts.Response.root_uri)
}
#if LANG_CXX11
inline void ListArtifacts_Response::set_root_uri(::std::string&& value) {
  set_has_root_uri();
  root_uri_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.ListArtifacts.Response.root_uri)
}
#endif
inline void ListArtifacts_Response::set_root_uri(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_root_uri();
  root_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.ListArtifacts.Response.root_uri)
}
inline void ListArtifacts_Response::set_root_uri(const char* value, size_t size) {
  set_has_root_uri();
  root_uri_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.ListArtifacts.Response.root_uri)
}
inline ::std::string* ListArtifacts_Response::mutable_root_uri() {
  set_has_root_uri();
  // @@protoc_insertion_point(field_mutable:mlflow.ListArtifacts.Response.root_uri)
  return root_uri_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifacts_Response::release_root_uri() {
  // @@protoc_insertion_point(field_release:mlflow.ListArtifacts.Response.root_uri)
  if (!has_root_uri()) {
    return NULL;
  }
  clear_has_root_uri();
  return root_uri_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifacts_Response::set_allocated_root_uri(::std::string* root_uri) {
  if (root_uri != NULL) {
    set_has_root_uri();
  } else {
    clear_has_root_uri();
  }
  root_uri_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root_uri);
  // @@protoc_insertion_point(field_set_allocated:mlflow.ListArtifacts.Response.root_uri)
}

// repeated .mlflow.FileInfo files = 2;
inline int ListArtifacts_Response::files_size() const {
  return files_.size();
}
inline void ListArtifacts_Response::clear_files() {
  files_.Clear();
}
inline ::mlflow::FileInfo* ListArtifacts_Response::mutable_files(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.ListArtifacts.Response.files)
  return files_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::FileInfo >*
ListArtifacts_Response::mutable_files() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.ListArtifacts.Response.files)
  return &files_;
}
inline const ::mlflow::FileInfo& ListArtifacts_Response::files(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.ListArtifacts.Response.files)
  return files_.Get(index);
}
inline ::mlflow::FileInfo* ListArtifacts_Response::add_files() {
  // @@protoc_insertion_point(field_add:mlflow.ListArtifacts.Response.files)
  return files_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::FileInfo >&
ListArtifacts_Response::files() const {
  // @@protoc_insertion_point(field_list:mlflow.ListArtifacts.Response.files)
  return files_;
}

// -------------------------------------------------------------------

// ListArtifacts

// optional string run_uuid = 1;
inline bool ListArtifacts::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListArtifacts::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListArtifacts::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListArtifacts::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& ListArtifacts::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.ListArtifacts.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void ListArtifacts::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.ListArtifacts.run_uuid)
}
#if LANG_CXX11
inline void ListArtifacts::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.ListArtifacts.run_uuid)
}
#endif
inline void ListArtifacts::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.ListArtifacts.run_uuid)
}
inline void ListArtifacts::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.ListArtifacts.run_uuid)
}
inline ::std::string* ListArtifacts::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.ListArtifacts.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifacts::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.ListArtifacts.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifacts::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.ListArtifacts.run_uuid)
}

// optional string path = 2;
inline bool ListArtifacts::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListArtifacts::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListArtifacts::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListArtifacts::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& ListArtifacts::path() const {
  // @@protoc_insertion_point(field_get:mlflow.ListArtifacts.path)
  return path_.GetNoArena();
}
inline void ListArtifacts::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.ListArtifacts.path)
}
#if LANG_CXX11
inline void ListArtifacts::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.ListArtifacts.path)
}
#endif
inline void ListArtifacts::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.ListArtifacts.path)
}
inline void ListArtifacts::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.ListArtifacts.path)
}
inline ::std::string* ListArtifacts::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mlflow.ListArtifacts.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ListArtifacts::release_path() {
  // @@protoc_insertion_point(field_release:mlflow.ListArtifacts.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ListArtifacts::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mlflow.ListArtifacts.path)
}

// -------------------------------------------------------------------

// FileInfo

// optional string path = 1;
inline bool FileInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& FileInfo::path() const {
  // @@protoc_insertion_point(field_get:mlflow.FileInfo.path)
  return path_.GetNoArena();
}
inline void FileInfo::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.FileInfo.path)
}
#if LANG_CXX11
inline void FileInfo::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.FileInfo.path)
}
#endif
inline void FileInfo::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.FileInfo.path)
}
inline void FileInfo::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.FileInfo.path)
}
inline ::std::string* FileInfo::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mlflow.FileInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FileInfo::release_path() {
  // @@protoc_insertion_point(field_release:mlflow.FileInfo.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FileInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mlflow.FileInfo.path)
}

// optional bool is_dir = 2;
inline bool FileInfo::has_is_dir() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FileInfo::set_has_is_dir() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FileInfo::clear_has_is_dir() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FileInfo::clear_is_dir() {
  is_dir_ = false;
  clear_has_is_dir();
}
inline bool FileInfo::is_dir() const {
  // @@protoc_insertion_point(field_get:mlflow.FileInfo.is_dir)
  return is_dir_;
}
inline void FileInfo::set_is_dir(bool value) {
  set_has_is_dir();
  is_dir_ = value;
  // @@protoc_insertion_point(field_set:mlflow.FileInfo.is_dir)
}

// optional int64 file_size = 3;
inline bool FileInfo::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileInfo::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileInfo::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileInfo::clear_file_size() {
  file_size_ = GOOGLE_LONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::int64 FileInfo::file_size() const {
  // @@protoc_insertion_point(field_get:mlflow.FileInfo.file_size)
  return file_size_;
}
inline void FileInfo::set_file_size(::google::protobuf::int64 value) {
  set_has_file_size();
  file_size_ = value;
  // @@protoc_insertion_point(field_set:mlflow.FileInfo.file_size)
}

// -------------------------------------------------------------------

// GetArtifact_Response

// -------------------------------------------------------------------

// GetArtifact

// optional string run_uuid = 1;
inline bool GetArtifact::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetArtifact::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetArtifact::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetArtifact::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& GetArtifact::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.GetArtifact.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void GetArtifact::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetArtifact.run_uuid)
}
#if LANG_CXX11
inline void GetArtifact::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetArtifact.run_uuid)
}
#endif
inline void GetArtifact::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetArtifact.run_uuid)
}
inline void GetArtifact::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetArtifact.run_uuid)
}
inline ::std::string* GetArtifact::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.GetArtifact.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetArtifact::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.GetArtifact.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetArtifact::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetArtifact.run_uuid)
}

// optional string path = 2;
inline bool GetArtifact::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetArtifact::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetArtifact::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetArtifact::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
inline const ::std::string& GetArtifact::path() const {
  // @@protoc_insertion_point(field_get:mlflow.GetArtifact.path)
  return path_.GetNoArena();
}
inline void GetArtifact::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetArtifact.path)
}
#if LANG_CXX11
inline void GetArtifact::set_path(::std::string&& value) {
  set_has_path();
  path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetArtifact.path)
}
#endif
inline void GetArtifact::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetArtifact.path)
}
inline void GetArtifact::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetArtifact.path)
}
inline ::std::string* GetArtifact::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mlflow.GetArtifact.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetArtifact::release_path() {
  // @@protoc_insertion_point(field_release:mlflow.GetArtifact.path)
  if (!has_path()) {
    return NULL;
  }
  clear_has_path();
  return path_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetArtifact::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetArtifact.path)
}

// -------------------------------------------------------------------

// GetMetricHistory_Response

// repeated .mlflow.Metric metrics = 1;
inline int GetMetricHistory_Response::metrics_size() const {
  return metrics_.size();
}
inline void GetMetricHistory_Response::clear_metrics() {
  metrics_.Clear();
}
inline ::mlflow::Metric* GetMetricHistory_Response::mutable_metrics(int index) {
  // @@protoc_insertion_point(field_mutable:mlflow.GetMetricHistory.Response.metrics)
  return metrics_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >*
GetMetricHistory_Response::mutable_metrics() {
  // @@protoc_insertion_point(field_mutable_list:mlflow.GetMetricHistory.Response.metrics)
  return &metrics_;
}
inline const ::mlflow::Metric& GetMetricHistory_Response::metrics(int index) const {
  // @@protoc_insertion_point(field_get:mlflow.GetMetricHistory.Response.metrics)
  return metrics_.Get(index);
}
inline ::mlflow::Metric* GetMetricHistory_Response::add_metrics() {
  // @@protoc_insertion_point(field_add:mlflow.GetMetricHistory.Response.metrics)
  return metrics_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mlflow::Metric >&
GetMetricHistory_Response::metrics() const {
  // @@protoc_insertion_point(field_list:mlflow.GetMetricHistory.Response.metrics)
  return metrics_;
}

// -------------------------------------------------------------------

// GetMetricHistory

// optional string run_uuid = 1 [(.validate_required) = true];
inline bool GetMetricHistory::has_run_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetMetricHistory::set_has_run_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetMetricHistory::clear_has_run_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetMetricHistory::clear_run_uuid() {
  run_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_run_uuid();
}
inline const ::std::string& GetMetricHistory::run_uuid() const {
  // @@protoc_insertion_point(field_get:mlflow.GetMetricHistory.run_uuid)
  return run_uuid_.GetNoArena();
}
inline void GetMetricHistory::set_run_uuid(const ::std::string& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetMetricHistory.run_uuid)
}
#if LANG_CXX11
inline void GetMetricHistory::set_run_uuid(::std::string&& value) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetMetricHistory.run_uuid)
}
#endif
inline void GetMetricHistory::set_run_uuid(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetMetricHistory.run_uuid)
}
inline void GetMetricHistory::set_run_uuid(const char* value, size_t size) {
  set_has_run_uuid();
  run_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetMetricHistory.run_uuid)
}
inline ::std::string* GetMetricHistory::mutable_run_uuid() {
  set_has_run_uuid();
  // @@protoc_insertion_point(field_mutable:mlflow.GetMetricHistory.run_uuid)
  return run_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMetricHistory::release_run_uuid() {
  // @@protoc_insertion_point(field_release:mlflow.GetMetricHistory.run_uuid)
  if (!has_run_uuid()) {
    return NULL;
  }
  clear_has_run_uuid();
  return run_uuid_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMetricHistory::set_allocated_run_uuid(::std::string* run_uuid) {
  if (run_uuid != NULL) {
    set_has_run_uuid();
  } else {
    clear_has_run_uuid();
  }
  run_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), run_uuid);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetMetricHistory.run_uuid)
}

// optional string metric_key = 2 [(.validate_required) = true];
inline bool GetMetricHistory::has_metric_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetMetricHistory::set_has_metric_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetMetricHistory::clear_has_metric_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetMetricHistory::clear_metric_key() {
  metric_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_metric_key();
}
inline const ::std::string& GetMetricHistory::metric_key() const {
  // @@protoc_insertion_point(field_get:mlflow.GetMetricHistory.metric_key)
  return metric_key_.GetNoArena();
}
inline void GetMetricHistory::set_metric_key(const ::std::string& value) {
  set_has_metric_key();
  metric_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mlflow.GetMetricHistory.metric_key)
}
#if LANG_CXX11
inline void GetMetricHistory::set_metric_key(::std::string&& value) {
  set_has_metric_key();
  metric_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:mlflow.GetMetricHistory.metric_key)
}
#endif
inline void GetMetricHistory::set_metric_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_metric_key();
  metric_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mlflow.GetMetricHistory.metric_key)
}
inline void GetMetricHistory::set_metric_key(const char* value, size_t size) {
  set_has_metric_key();
  metric_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mlflow.GetMetricHistory.metric_key)
}
inline ::std::string* GetMetricHistory::mutable_metric_key() {
  set_has_metric_key();
  // @@protoc_insertion_point(field_mutable:mlflow.GetMetricHistory.metric_key)
  return metric_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetMetricHistory::release_metric_key() {
  // @@protoc_insertion_point(field_release:mlflow.GetMetricHistory.metric_key)
  if (!has_metric_key()) {
    return NULL;
  }
  clear_has_metric_key();
  return metric_key_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetMetricHistory::set_allocated_metric_key(::std::string* metric_key) {
  if (metric_key != NULL) {
    set_has_metric_key();
  } else {
    clear_has_metric_key();
  }
  metric_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), metric_key);
  // @@protoc_insertion_point(field_set_allocated:mlflow.GetMetricHistory.metric_key)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace mlflow

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::mlflow::ViewType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mlflow::ViewType>() {
  return ::mlflow::ViewType_descriptor();
}
template <> struct is_proto_enum< ::mlflow::SourceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mlflow::SourceType>() {
  return ::mlflow::SourceType_descriptor();
}
template <> struct is_proto_enum< ::mlflow::RunStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::mlflow::RunStatus>() {
  return ::mlflow::RunStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_service_2eproto
